(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{529:function(t,_,a){"use strict";a.r(_);var e=a(5),v=Object(e.a)({},(function(){var t=this,_=t.$createElement,a=t._self._c||_;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"三、unity脚本基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、unity脚本基础"}},[t._v("#")]),t._v(" 三、Unity脚本基础")]),t._v(" "),a("h2",{attrs:{id:"_1-unity3d中的协程-coroutine-和c-线程之间的区别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-unity3d中的协程-coroutine-和c-线程之间的区别是什么"}},[t._v("#")]),t._v(" 1.    Unity3D中的协程（coroutine）和C#线程之间的区别是什么？")]),t._v(" "),a("p",[t._v("多线程程序同时运行多个线程 ，而在任一指定时刻只有一个协程在运行，并且这个正在运行的协同程序只在必要时才被挂起。除主线程之外的线程无法访问 Unity3D 的对象、组件、方法。")]),t._v(" "),a("p",[t._v("Unity3d 没有多线程的概念，不过 unity 也给我们提供了 StartCoroutine（协同程序）和LoadLevelAsync（异步加载关卡）后台加载场景的方法。 StartCoroutine 为什么叫协同程序呢，所谓协同，就是当你在 StartCoroutine 的函数体里处理一段代码时，利用 yield 语句等待执行结果，这期间不影响主程序的继续执行，可以协同工作。而 LoadLevelAsync 则允许你在后台加载新资源和场景，所以再利用协同，你就可以前台用 loading 条或动画提示玩家游戏未卡死，同时后台协同处理加载的事宜")]),t._v(" "),a("h2",{attrs:{id:"_2-简述-unity3d-支持的作为脚本的语言的名称"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-简述-unity3d-支持的作为脚本的语言的名称"}},[t._v("#")]),t._v(" 2.    简述 Unity3D 支持的作为脚本的语言的名称")]),t._v(" "),a("p",[t._v("Unity 的脚本语言基于 Mono 的.Net 平台上运行，可以使用.NET 库，这也为 XML、数据库、正则表达式等问题提供了很好的解决方案。")]),t._v(" "),a("p",[t._v("Unity 里的脚本都会经过编译，他们的运行速度也很快。这三种语言实际上的功能和运行速度是一样的，区别主要体现在语言特性上。")]),t._v(" "),a("p",[t._v("JavaScript：和网页中常用的 JavaScript 不一样，它编译后的运行速度很快，语法方面也会有不少区别。")]),t._v(" "),a("p",[t._v("C#")]),t._v(" "),a("p",[t._v("Boo：可以看做是 Python 语言的变种，又糅合了 Ruby 和 C#的特性，它是静态类型语言")]),t._v(" "),a("h2",{attrs:{id:"_3-unity3d-是否支持写成多线程程序-如果支持的话需要注意什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-unity3d-是否支持写成多线程程序-如果支持的话需要注意什么"}},[t._v("#")]),t._v(" 3.    Unity3D 是否支持写成多线程程序？如果支持的话需要注意什么？")]),t._v(" "),a("p",[t._v("仅能从主线程中访问 Unity3D 的组件，对象和 Unity3D 系统调用")]),t._v(" "),a("h2",{attrs:{id:"_4-支持-如果同时你要处理很多事情或者与-unity-的对象互动小可以用-thread-否则使用coroutine。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-支持-如果同时你要处理很多事情或者与-unity-的对象互动小可以用-thread-否则使用coroutine。"}},[t._v("#")]),t._v(" 4.    支持：如果同时你要处理很多事情或者与 Unity 的对象互动小可以用 thread,否则使用coroutine。")]),t._v(" "),a("p",[t._v("注意：C#中有 lock 这个关键字,以确保只有一个线程可以在特定时间内访问特定的对象")]),t._v(" "),a("h2",{attrs:{id:"_5-onenable、awake、start-运行时的发生顺序-哪些可能在同一个对象周期中反复的发生"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-onenable、awake、start-运行时的发生顺序-哪些可能在同一个对象周期中反复的发生"}},[t._v("#")]),t._v(" 5.    OnEnable、Awake、Start 运行时的发生顺序？哪些可能在同一个对象周期中反复的发生？")]),t._v(" "),a("p",[t._v("Awake -》OnEnable-》Start")]),t._v(" "),a("p",[t._v("OnEnable 在同一周期中可以反复地发生")]),t._v(" "),a("h2",{attrs:{id:"_6-请简述-onbecamevisible-及-onbecameinvisible-的发生时机-以及这一对回调函数的意义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-请简述-onbecamevisible-及-onbecameinvisible-的发生时机-以及这一对回调函数的意义"}},[t._v("#")]),t._v(" 6.    请简述 OnBecameVisible 及 OnBecameInvisible 的发生时机，以及这一对回调函数的意义？")]),t._v(" "),a("p",[t._v("当物体是否可见切换之时。可以用于只需要在物体可见时才进行的计算。")]),t._v(" "),a("h2",{attrs:{id:"_7-unity3d-如何获知场景中需要加载的数据"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-unity3d-如何获知场景中需要加载的数据"}},[t._v("#")]),t._v(" 7.    Unity3D 如何获知场景中需要加载的数据？")]),t._v(" "),a("p",[t._v("Resource.Load")]),t._v(" "),a("p",[t._v("AssetBundle.Load")]),t._v(" "),a("h2",{attrs:{id:"_8-物体发生碰撞时-有几个阶段-分别对应的函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-物体发生碰撞时-有几个阶段-分别对应的函数"}},[t._v("#")]),t._v(" 8.    物体发生碰撞时，有几个阶段，分别对应的函数")]),t._v(" "),a("p",[t._v("三个阶段，OnCollisionEnter/Stay/Exit 函数")]),t._v(" "),a("h2",{attrs:{id:"_9-u3d-中-几种施加力的方式-描述出来"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-u3d-中-几种施加力的方式-描述出来"}},[t._v("#")]),t._v(" 9.    u3d 中，几种施加力的方式，描述出来")]),t._v(" "),a("p",[t._v("rigidbody.AddForce/AddForceAtPosition，都是 rigidbody 的成员函数")]),t._v(" "),a("h2",{attrs:{id:"_10-物体自旋转使用的函数叫什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-物体自旋转使用的函数叫什么"}},[t._v("#")]),t._v(" 10. 物体自旋转使用的函数叫什么")]),t._v(" "),a("p",[t._v("transform.Rotate")]),t._v(" "),a("h2",{attrs:{id:"_11-物体绕某点旋转使用函数叫什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-物体绕某点旋转使用函数叫什么"}},[t._v("#")]),t._v(" 11. 物体绕某点旋转使用函数叫什么")]),t._v(" "),a("p",[t._v("transform.RotateAround")]),t._v(" "),a("h2",{attrs:{id:"_12-u3d-提供了一个用于保存读取数据的类-playerprefs-请列出保存读取整形数据的函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-u3d-提供了一个用于保存读取数据的类-playerprefs-请列出保存读取整形数据的函数"}},[t._v("#")]),t._v(" 12. u3d 提供了一个用于保存读取数据的类，（playerPrefs），请列出保存读取整形数据的函数")]),t._v(" "),a("p",[t._v("PlayerPrefs.SetInt 与 PlayerPrefs.GetInt")]),t._v(" "),a("h2",{attrs:{id:"_13-unity3d-从唤醒到销毁有一段生命周期-请列出系统自己调用的几个重要方法。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-unity3d-从唤醒到销毁有一段生命周期-请列出系统自己调用的几个重要方法。"}},[t._v("#")]),t._v(" 13. unity3d 从唤醒到销毁有一段生命周期，请列出系统自己调用的几个重要方法。")]),t._v(" "),a("p",[t._v("Awake –>OnEnable –> Start –> Update –> FixedUpdate –> LateUpdate –>OnGUI –> Reset –> OnDisable –> OnDestroy")]),t._v(" "),a("h2",{attrs:{id:"_14-物理更新一般在哪个系统函数里"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-物理更新一般在哪个系统函数里"}},[t._v("#")]),t._v(" 14. 物理更新一般在哪个系统函数里？")]),t._v(" "),a("p",[t._v("FixedUpdate，每固定帧绘制时执行一次，和 update 不同的是 FixedUpdate 是渲染帧执行，如果你的渲染效率低下的时候 FixedUpdate 调用次数就会跟着下降。FixedUpdate 比较适用于物理引擎的计算，因为是跟每帧渲染有关。Update 就比较适合做控制。")]),t._v(" "),a("h2",{attrs:{id:"_15-移动相机动作在哪个函数里-为什么在这个函数里。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-移动相机动作在哪个函数里-为什么在这个函数里。"}},[t._v("#")]),t._v(" 15. 移动相机动作在哪个函数里，为什么在这个函数里。")]),t._v(" "),a("p",[t._v("LateUpdate,，是在所有 update 结束后才调，比较适合用于命令脚本的执行。官网上例子是摄像机的跟随，都是在所有 update 操作完才跟进摄像机，不然就有可能出现摄像机已经推进了，但是视角里还未有角色的空帧出现。")]),t._v(" "),a("h2",{attrs:{id:"_16-为什么-u3d-会出现组件上数据丢失的情况"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-为什么-u3d-会出现组件上数据丢失的情况"}},[t._v("#")]),t._v(" 16. 为什么 u3d 会出现组件上数据丢失的情况")]),t._v(" "),a("p",[t._v("一般是组件上绑定的物体对象被删除了")]),t._v(" "),a("h2",{attrs:{id:"_17-什么是协同程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-什么是协同程序"}},[t._v("#")]),t._v(" 17. 什么是协同程序？")]),t._v(" "),a("p",[t._v("在主线程运行时同时开启另一段逻辑处理，来协助当前程序的执行。换句话说，开启协程就是开启一个线程。可以用来控制运动、序列以及对象的行为。")]),t._v(" "),a("h2",{attrs:{id:"_18-反向旋转动画的方法是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-反向旋转动画的方法是什么"}},[t._v("#")]),t._v(" 18. 反向旋转动画的方法是什么？")]),t._v(" "),a("p",[t._v("反转动画，讲动画的速度调到-1，碰撞时，被碰撞物体与碰撞物体有collider 组件，碰撞物体有刚体组件，或角色碰撞得包含角色组件 OR 改变 animation.speed")]),t._v(" "),a("h2",{attrs:{id:"_19-用代码实现第三角色控制器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-用代码实现第三角色控制器"}},[t._v("#")]),t._v(" 19. 用代码实现第三角色控制器")]),t._v(" "),a("p",[t._v("public class Player : MonoBehaviour {")]),t._v(" "),a("p",[t._v("public Transform _cameraTrans;")]),t._v(" "),a("p",[t._v("private Vector3 _cameraOffset;")]),t._v(" "),a("p",[t._v("void Awake() {")]),t._v(" "),a("p",[t._v("​    _cameraOffset = transform.position - _cameraTrans.position;")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("void Update() {")]),t._v(" "),a("p",[t._v("​    _cameraTrans.position = transform.position - _cameraOffset;")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("h2",{attrs:{id:"_20-实现吊机吊物体的功能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-实现吊机吊物体的功能"}},[t._v("#")]),t._v(" 20. 实现吊机吊物体的功能")]),t._v(" "),a("p",[t._v("吊机吊物体需要节点挂接和坐标系转换")]),t._v(" "),a("h2",{attrs:{id:"_21-获取、增加、删除组件的命令分别是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-获取、增加、删除组件的命令分别是什么"}},[t._v("#")]),t._v(" 21. 获取、增加、删除组件的命令分别是什么")]),t._v(" "),a("p",[t._v("获取：GetComponent")]),t._v(" "),a("p",[t._v("增加：AddComponent")]),t._v(" "),a("p",[t._v("删除：Destroy")]),t._v(" "),a("h2",{attrs:{id:"_22-animation-crossfade-命令作用是-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-animation-crossfade-命令作用是-c"}},[t._v("#")]),t._v(" 22. Animation.CrossFade 命令作用是：C")]),t._v(" "),a("p",[t._v("A.   动画放大 B.动画转换 C.动画的淡入为其他动画")]),t._v(" "),a("h2",{attrs:{id:"_23-application-loadlevel-命令为-a"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-application-loadlevel-命令为-a"}},[t._v("#")]),t._v(" 23. Application.loadLevel 命令为：A")]),t._v(" "),a("p",[t._v("A.   加载关卡 B.异步加载关卡 C.加载动作")]),t._v(" "),a("h2",{attrs:{id:"_24-调试记录到控制台的命令是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-调试记录到控制台的命令是什么"}},[t._v("#")]),t._v(" 24. 调试记录到控制台的命令是什么？")]),t._v(" "),a("p",[t._v("Debug.Log();")]),t._v(" "),a("h2",{attrs:{id:"_25-编辑器类存放路径是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-编辑器类存放路径是什么"}},[t._v("#")]),t._v(" 25. 编辑器类存放路径是什么？")]),t._v(" "),a("p",[t._v("工程目录下的 Assets/Editor 文件夹下。")]),t._v(" "),a("h2",{attrs:{id:"_26-使用原生-gui-创建一个可以拖动的窗口命令是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-使用原生-gui-创建一个可以拖动的窗口命令是什么"}},[t._v("#")]),t._v(" 26. 使用原生 GUI 创建一个可以拖动的窗口命令是什么？")]),t._v(" "),a("p",[t._v("GUI.DragWindow();")]),t._v(" "),a("h2",{attrs:{id:"_27-localposition-与-position-的使用区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-localposition-与-position-的使用区别"}},[t._v("#")]),t._v(" 27. localPosition 与 Position 的使用区别？")]),t._v(" "),a("p",[t._v("localPosition：自身位置，相对于父级的变换的位置。 Position：在世界坐标 transform的位置")]),t._v(" "),a("h2",{attrs:{id:"_28-含义mathf-round-mathf-clamp-mathf-lerp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_28-含义mathf-round-mathf-clamp-mathf-lerp"}},[t._v("#")]),t._v(" 28. 含义Mathf.Round, Mathf.Clamp, Mathf.Lerp")]),t._v(" "),a("p",[t._v("Mathf.Round 四舍五入")]),t._v(" "),a("p",[t._v("Mathf.Clamp 限制")]),t._v(" "),a("p",[t._v("Mathf.Lerp 插值")]),t._v(" "),a("h2",{attrs:{id:"_29-写一个计时器工具-从整点开始计时-格式为-00-00-00"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-写一个计时器工具-从整点开始计时-格式为-00-00-00"}},[t._v("#")]),t._v(" 29. 写一个计时器工具，从整点开始计时，格式为：00:00:00")]),t._v(" "),a("p",[t._v("private float timer = 0f;")]),t._v(" "),a("p",[t._v("private int h = 0;")]),t._v(" "),a("p",[t._v("private int m = 0;")]),t._v(" "),a("p",[t._v("private int s = 0;")]),t._v(" "),a("p",[t._v("private string timeStr = string.Empty;")]),t._v(" "),a("p",[t._v("void Update () {")]),t._v(" "),a("p",[t._v("timer += Time.deltaTime;")]),t._v(" "),a("p",[t._v("if (timer >= 1f) {s++; timer = 0;}")]),t._v(" "),a("p",[t._v("if (s >= 60) {m++;s = 0;}")]),t._v(" "),a("p",[t._v("if (m >= 60) {h++;m = 0;}")]),t._v(" "),a("p",[t._v("if (h >= 99) {h = 0;}")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("void OnGUI(){")]),t._v(" "),a("p",[t._v('timeStr = string.Format ("{0:D2}:{1:D2}:{2:D2}", h, m, s);')]),t._v(" "),a("p",[t._v("GUI.Label (new Rect (10, 10, 100, 200), timeStr);")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("h2",{attrs:{id:"_30-写出-animation-的五个方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-写出-animation-的五个方法"}},[t._v("#")]),t._v(" 30. 写出 Animation 的五个方法")]),t._v(" "),a("p",[t._v("AddClip 添加剪辑、Blend 混合、Play 播放、Stop 停止、Sample 采样")]),t._v(" "),a("h2",{attrs:{id:"_31-用鼠标实现在场景中拖动物体-用鼠标滚轮实现缩放-用一个-cube-即可-。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-用鼠标实现在场景中拖动物体-用鼠标滚轮实现缩放-用一个-cube-即可-。"}},[t._v("#")]),t._v(" 31. 用鼠标实现在场景中拖动物体，用鼠标滚轮实现缩放(用一个 Cube 即可)。")]),t._v(" "),a("p",[t._v("在场景中添加一个Plan，Camera，Directional Light，Cube。添加两个脚本scrollerScirpt（挂在Camera），CubeDragScript（挂在Cube上）。")]),t._v(" "),a("p",[t._v("1.鼠标滚轮实现缩放：将摄像机的镜头拉近或者拉远，调整摄像机的视角就可以实现，主要实现代码如下：")]),t._v(" "),a("p",[t._v("void Update () {")]),t._v(" "),a("p",[t._v("//鼠标滚轮的效果")]),t._v(" "),a("p",[t._v('if (Input.GetAxis("Mouse ScrollWheel") < 0) {')]),t._v(" "),a("p",[t._v("​      if (Camera.main.fieldOfView <= 100)")]),t._v(" "),a("p",[t._v("​        Camera.main.fieldOfView += 2;")]),t._v(" "),a("p",[t._v("​     if (Camera.main.orthographicSize <= 20)")]),t._v(" "),a("p",[t._v("​        Camera.main.orthographicSize += 0.5F;")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("//Zoom in")]),t._v(" "),a("p",[t._v('if (Input.GetAxis("Mouse ScrollWheel") > 0) {')]),t._v(" "),a("p",[t._v("​      if (Camera.main.fieldOfView > 2)")]),t._v(" "),a("p",[t._v("​        Camera.main.fieldOfView -= 2;")]),t._v(" "),a("p",[t._v("​     if (Camera.main.orthographicSize >= 1)")]),t._v(" "),a("p",[t._v("​        Camera.main.orthographicSize -= 0.5F;")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("2.鼠标实现在场景中拖动物体：")]),t._v(" "),a("p",[t._v("解决思路就是将世界坐标转换成屏幕坐标，然后计算物体与鼠标之间移动量，循环鼠标被按下操作，得到鼠标的当前位置，加上计算好的移动量，将新的坐标赋值给物理就行了。主要是开启一个协同程序（Corountine）来处理")]),t._v(" "),a("p",[t._v("主要代码如下：")]),t._v(" "),a("p",[t._v("// Use this for initialization")]),t._v(" "),a("p",[t._v("void Start () {")]),t._v(" "),a("p",[t._v("StartCoroutine(OnMouseDown());")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("IEnumerator OnMouseDown() {")]),t._v(" "),a("p",[t._v("//将物体由世界坐标系转换为屏幕坐标系")]),t._v(" "),a("p",[t._v("Vector3 screenSpace = Camera.main.WorldToScreenPoint(transform.position);")]),t._v(" "),a("p",[t._v("//完成两个步骤 1.由于鼠标的坐标系是2维，需要转换成3维的世界坐标系")]),t._v(" "),a("p",[t._v("//2.只有3维坐标情况下才能来计算鼠标位置与物理的距离，offset即是距离")]),t._v(" "),a("p",[t._v("//将鼠标屏幕坐标转为三维坐标，再算出物体位置与鼠标之间的距离")]),t._v(" "),a("p",[t._v("Vector3 offset = transform.position - Camera.main.ScreenToWorldPoint(new Vector3(Input.mousePosition.x, Input.mousePosition.y, screenSpace.z));")]),t._v(" "),a("p",[t._v("while (Input.GetMouseButton(0)) {")]),t._v(" "),a("p",[t._v("​     //得到现在鼠标的2维坐标系位置")]),t._v(" "),a("p",[t._v("​     Vector3 curScreenSpace = new Vector3(Input.mousePosition.x, Input.mousePosition.y, screenSpace.z);")]),t._v(" "),a("p",[t._v("​     //将当前鼠标的2维位置转换成3维位置，再加上鼠标的移动量")]),t._v(" "),a("p",[t._v("​     Vector3 curPosition = Camera.main.ScreenToWorldPoint(curScreenSpace) + offset;")]),t._v(" "),a("p",[t._v("​     //curPosition就是物体应该的移动向量赋给transform的position属性")]),t._v(" "),a("p",[t._v("​     transform.position = curPosition;")]),t._v(" "),a("p",[t._v("​     yield return new WaitForFixedUpdate(); //这个很重要，循环执行")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("h2",{attrs:{id:"_32-ngui-button-怎样接受用户点击并调用函数-具体方法名称是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_32-ngui-button-怎样接受用户点击并调用函数-具体方法名称是什么"}},[t._v("#")]),t._v(" 32. NGUI Button 怎样接受用户点击并调用函数,具体方法名称是什么")]),t._v(" "),a("p",[t._v("1、主要是在UICamera脚本中用射线判断点击的物体并通过SendMessage调用OnClick() OnPress()等函数，可以说NGUI的按钮是通过发消息这个方式调用的。具体方法名称是OnClick()")]),t._v(" "),a("p",[t._v("2、void Awake () {")]),t._v(" "),a("p",[t._v("​    //获取需要监听的按钮对象")]),t._v(" "),a("p",[t._v('​    GameObject button = GameObject.Find("UI Root/Button3");')]),t._v(" "),a("p",[t._v("​    //设置这个按钮的监听，指向本类的ButtonClick方法中。")]),t._v(" "),a("p",[t._v("​    UIEventListener.Get(button).onClick = OnButton3Click;")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("private void OnButton3Click(GameObject button) {")]),t._v(" "),a("p",[t._v('​    Debug.Log("我是按钮3被点击了");')]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("h2",{attrs:{id:"_33-愤怒的小鸟-给予初速度以后-怎么让小鸟受到重力和空气阻力的影响而绘制抛物线轨迹-说出具体的计算方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_33-愤怒的小鸟-给予初速度以后-怎么让小鸟受到重力和空气阻力的影响而绘制抛物线轨迹-说出具体的计算方法"}},[t._v("#")]),t._v(" 33. <愤怒的小鸟>给予初速度以后,怎么让小鸟受到重力和空气阻力的影响而绘制抛物线轨迹,说出具体的计算方法.")]),t._v(" "),a("p",[t._v("Vector3 v 代表初速度 v'代表现在的速度， 假设小鸟是沿的 z 轴也就是 transform.forward方向运动的质量为 1，那么 v'=v-new Vector3(0,g"),a("em",[t._v("t,f")]),t._v("t)，transform.Translate(v')做的就是抛物线运动（g 为重力加速度不要用现实中的需要自己调试，f 为阻力也要自己调试设置，t 为时间）")]),t._v(" "),a("h2",{attrs:{id:"_34-当游戏中需要频繁创建一个物体时-我们需要怎样做能够节省内存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_34-当游戏中需要频繁创建一个物体时-我们需要怎样做能够节省内存"}},[t._v("#")]),t._v(" 34. 当游戏中需要频繁创建一个物体时，我们需要怎样做能够节省内存？")]),t._v(" "),a("p",[t._v("1、使用预制物体对象 Prefab")]),t._v(" "),a("p",[t._v("2、使用对象池技术，不使用时关闭，使用时打开")]),t._v(" "),a("h2",{attrs:{id:"_35-碰撞检测需要物体具备什么属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_35-碰撞检测需要物体具备什么属性"}},[t._v("#")]),t._v(" 35. 碰撞检测需要物体具备什么属性？")]),t._v(" "),a("p",[t._v("能检测碰撞发生的方式有两种，一种是利用碰撞器，另一种则是利用触发器")]),t._v(" "),a("p",[t._v("【Physics.OverlapSphere 相交球检测碰撞，碰撞检测需要包围盒】")]),t._v(" "),a("h2",{attrs:{id:"_36-vector3-forward与vector3-0-0-1-是一样的意思对吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_36-vector3-forward与vector3-0-0-1-是一样的意思对吗"}},[t._v("#")]),t._v(" 36. Vector3.forward与Vector3(0,0,1)是一样的意思对吗？")]),t._v(" "),a("p",[t._v("对")]),t._v(" "),a("h2",{attrs:{id:"_37-下哪个函数在游戏进入新场景后会被马上调用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_37-下哪个函数在游戏进入新场景后会被马上调用"}},[t._v("#")]),t._v(" 37. 下哪个函数在游戏进入新场景后会被马上调用？")]),t._v(" "),a("p",[t._v("MonoBehaviour.OnLevelWasLoaded")]),t._v(" "),a("h2",{attrs:{id:"_38-itween-插件的作用是什么-itween-作用于世界坐标还是局部坐标-请列举出-3-个其常用方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_38-itween-插件的作用是什么-itween-作用于世界坐标还是局部坐标-请列举出-3-个其常用方法"}},[t._v("#")]),t._v(" 38. itween 插件的作用是什么，itween 作用于世界坐标还是局部坐标，请列举出 3 个其常用方法？")]),t._v(" "),a("p",[t._v("iTween 是一个动画库，作者创建它的目的就是最小的投入实现最大的产出。让你做开发更轻松，用它可以轻松实现各种动画，晃动，旋转，移动，褪色，上色，控制音频等等“方法：")]),t._v(" "),a("p",[t._v("a、MoveTo 物体移动；")]),t._v(" "),a("p",[t._v("b、ColorTo：随着时间改变对象的颜色组；")]),t._v(" "),a("p",[t._v("c、LookTo：随时间旋转物体让其脸部朝向所提供的 Vector3 或 Transform 位置；")]),t._v(" "),a("h2",{attrs:{id:"_39-u3d-中用于记录节点空间几何信息的组件名称-及其父类名称"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_39-u3d-中用于记录节点空间几何信息的组件名称-及其父类名称"}},[t._v("#")]),t._v(" 39. U3D 中用于记录节点空间几何信息的组件名称，及其父类名称")]),t._v(" "),a("p",[t._v("Transform 父类是 Component")]),t._v(" "),a("h2",{attrs:{id:"_40-ngui-把子控件放在父控件里面-如何上下边距都是10。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_40-ngui-把子控件放在父控件里面-如何上下边距都是10。"}},[t._v("#")]),t._v(" 40. NGUI:把子控件放在父控件里面，如何上下边距都是10。")]),t._v(" "),a("p",[t._v("给子控件设置上下两个锚点为10")]),t._v(" "),a("h2",{attrs:{id:"_41-如何使子控件居中-如果使用ugui怎么实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_41-如何使子控件居中-如果使用ugui怎么实现"}},[t._v("#")]),t._v(" 41. 如何使子控件居中,如果使用UGUI怎么实现")]),t._v(" "),a("p",[t._v("设置子控件锚点为中心")]),t._v(" "),a("h2",{attrs:{id:"_42-去掉敏感字的程序-手写程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_42-去掉敏感字的程序-手写程序"}},[t._v("#")]),t._v(" 42. 去掉敏感字的程序（手写程序）")]),t._v(" "),a("p",[t._v('String s = "你是坏蛋";')]),t._v(" "),a("p",[t._v('s.Replace("坏蛋", "**");')]),t._v(" "),a("h2",{attrs:{id:"_43-unity3d从唤醒到销毁有一段生命周期-列出系统自己调用的重要方法。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_43-unity3d从唤醒到销毁有一段生命周期-列出系统自己调用的重要方法。"}},[t._v("#")]),t._v(" 43. unity3D从唤醒到销毁有一段生命周期，列出系统自己调用的重要方法。")]),t._v(" "),a("p",[t._v("Awake ()")]),t._v(" "),a("p",[t._v("OnEnable ()")]),t._v(" "),a("p",[t._v("Start()")]),t._v(" "),a("p",[t._v("FixedUpdate()")]),t._v(" "),a("p",[t._v("OnTriggerXXX(Collider other)")]),t._v(" "),a("p",[t._v("OnCollisionXXX (Collision collisionInfo)")]),t._v(" "),a("p",[t._v("Update()")]),t._v(" "),a("p",[t._v("LateUpdate ()")]),t._v(" "),a("p",[t._v("OnGUI()")]),t._v(" "),a("p",[t._v("OnDisable ()")]),t._v(" "),a("p",[t._v("OnDestroy ()")]),t._v(" "),a("h2",{attrs:{id:"_44-unity3d中resources目录一般用来放些什么-打包的时候会有什么影响"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_44-unity3d中resources目录一般用来放些什么-打包的时候会有什么影响"}},[t._v("#")]),t._v(" 44. Unity3d中resources目录一般用来放些什么，打包的时候会有什么影响？")]),t._v(" "),a("p",[t._v("resource一般用来放置一些需要动态加载的资源，打包程序的时候会将Resource目录下的全部文件都加密压缩打进包内，这样再想使用assetbundle方式打小包的话就不行了")]),t._v(" "),a("h2",{attrs:{id:"_45-空间内一物体绕球面固定点-0、1、2-按照固定速度speed环绕运动。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_45-空间内一物体绕球面固定点-0、1、2-按照固定速度speed环绕运动。"}},[t._v("#")]),t._v(" 45. 空间内一物体绕球面固定点（0、1、2）按照固定速度speed环绕运动。")]),t._v(" "),a("p",[t._v("public float Speed = 1;")]),t._v(" "),a("p",[t._v("void Update () {")]),t._v(" "),a("p",[t._v("transform.RotateAround (new Vector3(0,1,2),Vector3.up,Speed);")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("h2",{attrs:{id:"_46-以下关于www-loadfromcacheordownload描述正确的是-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_46-以下关于www-loadfromcacheordownload描述正确的是-c"}},[t._v("#")]),t._v(" 46. 以下关于WWW.LoadFromCacheOrDownload描述正确的是： C")]),t._v(" "),a("p",[t._v("A．可被用于将Text Assets自动缓存到本地磁盘")]),t._v(" "),a("p",[t._v("B．可被用于将Resource自动缓存到本地磁盘")]),t._v(" "),a("p",[t._v("C．可被用于将Assets Bundles自动缓存到本地磁盘")]),t._v(" "),a("p",[t._v("D．可被用于将任意的Unity资源文件自动缓存到本地磁盘")]),t._v(" "),a("h2",{attrs:{id:"_47-以下哪个函数在游戏进入新场景后会被马上调用-c"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_47-以下哪个函数在游戏进入新场景后会被马上调用-c"}},[t._v("#")]),t._v(" 47. 以下哪个函数在游戏进入新场景后会被马上调用？ C")]),t._v(" "),a("p",[t._v("A：MonoBehaviour.OnSceneWasLoaded")]),t._v(" "),a("p",[t._v("B：MonoBehaviour.OnSceneEnter")]),t._v(" "),a("p",[t._v("C：MonoBehaviour.OnLevelWasLoaded")]),t._v(" "),a("p",[t._v("D：MonoBehaviour.OnLevelEnter")]),t._v(" "),a("h2",{attrs:{id:"_48-关于monobehavior-lateupdate函数描述错误的是-b"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_48-关于monobehavior-lateupdate函数描述错误的是-b"}},[t._v("#")]),t._v(" 48. 关于MonoBehavior.LateUpdate函数描述错误的是： B")]),t._v(" "),a("p",[t._v("A．当MonoBehavior类型应用后，每帧调用一次")]),t._v(" "),a("p",[t._v("B．常被用于处理RigidBody的更新")]),t._v(" "),a("p",[t._v("C．在所有Update函数执行后才能被调用")]),t._v(" "),a("p",[t._v("D．常被用于实现跟随相机效果，且目标物体的位置已经在Update函数中被更新")]),t._v(" "),a("h2",{attrs:{id:"_49-某个gameobject有一个名为myscript的脚本-该脚本中有一个名为dosomething的函数-则如何在该gameobject的另一个脚本中国调用该函数-a"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_49-某个gameobject有一个名为myscript的脚本-该脚本中有一个名为dosomething的函数-则如何在该gameobject的另一个脚本中国调用该函数-a"}},[t._v("#")]),t._v(" 49. 某个GameObject有一个名为MyScript的脚本，该脚本中有一个名为DoSomething的函数，则如何在该GameObject的另一个脚本中国调用该函数？ A")]),t._v(" "),a("p",[t._v("A．GetComponent< MyScript>().DoSomething()")]),t._v(" "),a("p",[t._v('B．GetComponent< Script>("MyScript").DoSomething()')]),t._v(" "),a("p",[t._v('C．GetComponent< MyScript >().Call("DoSomething")')]),t._v(" "),a("p",[t._v('D．GetComponent< Script>("MyScript"). Call("DoSomething")')]),t._v(" "),a("h2",{attrs:{id:"_50-启用mipmaps对内存的影响是-a"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_50-启用mipmaps对内存的影响是-a"}},[t._v("#")]),t._v(" 50. 启用MipMaps对内存的影响是？ A")]),t._v(" "),a("p",[t._v("A．增加约33%的内存")]),t._v(" "),a("p",[t._v("B．减少约33%的内存")]),t._v(" "),a("p",[t._v("C．增加约25%的内存")]),t._v(" "),a("p",[t._v("D．减少约25%的内存")]),t._v(" "),a("h2",{attrs:{id:"_51-以下关于monobehaviour-ongui-的描述的是-d"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_51-以下关于monobehaviour-ongui-的描述的是-d"}},[t._v("#")]),t._v(" 51. 以下关于MonoBehaviour.OnGUI()的描述的是： D")]),t._v(" "),a("p",[t._v("A．如果MonoBehaviour没有被启用，则OnGUI函数不会被调用")]),t._v(" "),a("p",[t._v("B．用于绘制和处理GUI events")]),t._v(" "),a("p",[t._v("C．每帧可能会被绘制多次，每次对应于一个GUI event")]),t._v(" "),a("p",[t._v("D．每帧被调用一次")]),t._v(" "),a("h2",{attrs:{id:"_52-采用input-mouseposition来获取鼠标在屏幕上的位置-以下表述正确的是-b"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_52-采用input-mouseposition来获取鼠标在屏幕上的位置-以下表述正确的是-b"}},[t._v("#")]),t._v(" 52. 采用Input.mousePosition来获取鼠标在屏幕上的位置，以下表述正确的是： B")]),t._v(" "),a("p",[t._v("A．左上角为原点(0, 0)，右下角为(Screen.Width, Screen.Height)")]),t._v(" "),a("p",[t._v("B．左下角为原点(0, 0)，右上角为(Screen.Height, Screen.Width)")]),t._v(" "),a("p",[t._v("C．左下角为原点(0, 0)，右上角为(Screen.Width, Screen.Height)")]),t._v(" "),a("p",[t._v("D．左上角为原点(0, 0)，右下角为(Screen.Height, Screen.Height)")]),t._v(" "),a("h2",{attrs:{id:"_53-正确排列出下面unity脚本自带的函数执行顺序start-awake-update-onupdate-onenable-fixedupdate-ongui-lateupdate、ondisable、ondestory"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_53-正确排列出下面unity脚本自带的函数执行顺序start-awake-update-onupdate-onenable-fixedupdate-ongui-lateupdate、ondisable、ondestory"}},[t._v("#")]),t._v(" 53. 正确排列出下面Unity脚本自带的函数执行顺序Start，Awake，Update，OnUpdate，OnEnable，FixedUpdate，OnGUI，LateUpdate、OnDisable、OnDestory")]),t._v(" "),a("p",[t._v("Awake--\x3eOnEnable--\x3eStart--\x3eUpdate--\x3eFixedUpdate--\x3eLateUpdate--\x3eOnGUI--\x3eOnDisable --\x3eOnDestory")]),t._v(" "),a("h2",{attrs:{id:"_54-unity中销毁gameobject的方式-简述destroy和destroyimmediate的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_54-unity中销毁gameobject的方式-简述destroy和destroyimmediate的区别"}},[t._v("#")]),t._v(" 54. Unity中销毁GameObject的方式，简述Destroy和DestroyImmediate的区别")]),t._v(" "),a("p",[t._v("Destroy销毁场景中的物体，但是内存中它还是存在的，只有当内存不够时，机制才会将它销毁并释放内存。而DestroyImmediate会立即将对象销毁，并且将内存释放。")]),t._v(" "),a("h2",{attrs:{id:"_55-unity中如何派发事件-消息"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_55-unity中如何派发事件-消息"}},[t._v("#")]),t._v(" 55. Unity中如何派发事件（消息）")]),t._v(" "),a("p",[t._v("在脚本里的Update函数里调用EventDispatcher.Instance().OnTick();就可以了")]),t._v(" "),a("h2",{attrs:{id:"_56-scriptobject的作用和使用方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_56-scriptobject的作用和使用方式"}},[t._v("#")]),t._v(" 56. ScriptObject的作用和使用方式")]),t._v(" "),a("p",[t._v("ScriptObject类型经常使用于存储一些Unity本身不可以打包的一些object，比如字符串，一些类对象，用这个类型的子类型可以用BuildPipeline打包成assetbundle包共后续使用，非常方便。")]),t._v(" "),a("h2",{attrs:{id:"_57-如何检测物体是否被其他对象遮挡"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_57-如何检测物体是否被其他对象遮挡"}},[t._v("#")]),t._v(" 57. 如何检测物体是否被其他对象遮挡")]),t._v(" "),a("p",[t._v("使用射线进行检测")]),t._v(" "),a("h2",{attrs:{id:"_58-写一个角色控制器-鼠标控制屏幕晃动-鼠标控制开枪。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_58-写一个角色控制器-鼠标控制屏幕晃动-鼠标控制开枪。"}},[t._v("#")]),t._v(" 58. 写一个角色控制器，鼠标控制屏幕晃动，鼠标控制开枪。")]),t._v(" "),a("p",[t._v("public class Player : MonoBehaviour {")]),t._v(" "),a("p",[t._v("public GameObject _prefabBullet;")]),t._v(" "),a("p",[t._v("private float _angleSpeed = 120f;")]),t._v(" "),a("p",[t._v("void Update() {")]),t._v(" "),a("p",[t._v('​    float eularY = Input.GetAxis("Mouse X") * _angleSpeed * Time.deltaTime;')]),t._v(" "),a("p",[t._v("​    transform.Rotate(new Vector3(0, eularY, 0));")]),t._v(" "),a("p",[t._v("​    if (Input.GetMouseButtonDown(0)) {")]),t._v(" "),a("p",[t._v("​      Instantiate(_prefabBullet, transform.position, transform.rotation);")]),t._v(" "),a("p",[t._v("​    }")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("h2",{attrs:{id:"_59-敌人ai-有各种状态-实现各种状态之间的切换。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_59-敌人ai-有各种状态-实现各种状态之间的切换。"}},[t._v("#")]),t._v(" 59. 敌人AI，有各种状态，实现各种状态之间的切换。")]),t._v(" "),a("p",[t._v("通过状态机来实现各种状态之间的切换")]),t._v(" "),a("h2",{attrs:{id:"_60-1-写一个角色控制器-鼠标控制屏幕晃动-鼠标控制开枪。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_60-1-写一个角色控制器-鼠标控制屏幕晃动-鼠标控制开枪。"}},[t._v("#")]),t._v(" 60. 1.写一个角色控制器，鼠标控制屏幕晃动，鼠标控制开枪。")]),t._v(" "),a("p",[a("strong",[t._v("2."),a("strong",[a("strong",[t._v("敌人")])]),t._v("AI")]),t._v("**，有各种状态，实现各种状态之间的切换。**")]),t._v(" "),a("p",[a("strong",[t._v("3."),a("strong",[a("strong",[t._v("敌人会和主角对抗，敌人被打到之后，会闪一次红色，然后红色比例提升")])]),t._v("10%****，"),a("strong",[a("strong",[t._v("10")])]),t._v("次攻击之后，成红色。")])]),t._v(" "),a("p",[t._v("**4.**"),a("strong",[t._v("敌人会自动攻击主角，主角也会有颜色变化。")])]),t._v(" "),a("p",[t._v("**5.**"),a("strong",[t._v("敌人会在范围内巡逻。")])]),t._v(" "),a("p",[a("strong",[t._v("6.UI")]),t._v("**，左边显示"),a("strong",[a("strong",[t._v("8")])]),t._v("个"),a("strong",[a("strong",[t._v("AI")])]),t._v("的被攻击次数，右边显示"),a("strong",[a("strong",[t._v("AI")])]),t._v("的攻击次数排序。**")]),t._v(" "),a("p",[t._v("public class Player : MonoBehaviour {")]),t._v(" "),a("p",[t._v("public Camera _camera;")]),t._v(" "),a("p",[t._v("public GameObject _prefabBullet;")]),t._v(" "),a("p",[t._v("private float _angleSpeed = 120f;")]),t._v(" "),a("p",[t._v("//生命值")]),t._v(" "),a("p",[t._v("private int _life = 10;")]),t._v(" "),a("p",[t._v("//玩家的状态")]),t._v(" "),a("p",[t._v("private bool _state = false;")]),t._v(" "),a("p",[t._v("//是否被打到")]),t._v(" "),a("p",[t._v("public void IsState() {")]),t._v(" "),a("p",[t._v("​    if (_state && _life > 0) {")]),t._v(" "),a("p",[t._v("​      _life -= 1;")]),t._v(" "),a("p",[t._v("​      _state = false;")]),t._v(" "),a("p",[t._v("​    } else {")]),t._v(" "),a("p",[t._v("​      _state = true;")]),t._v(" "),a("p",[t._v("​    }")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("public void RoleRotate() {")]),t._v(" "),a("p",[t._v('​    float eularY = Input.GetAxis("Mouse X") * _angleSpeed * Time.deltaTime;')]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("//风发射子弹")]),t._v(" "),a("p",[t._v("public void RoleShoot() {")]),t._v(" "),a("p",[t._v("​    if (Input.GetMouseButtonDown(0)) {")]),t._v(" "),a("p",[t._v("​      Instantiate(_prefabBullet, transform.position, transform.rotation);")]),t._v(" "),a("p",[t._v("​    }")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("public class Enemy : MonoBehaviour {")]),t._v(" "),a("p",[t._v("//敌人被打到状态")]),t._v(" "),a("p",[t._v("private bool _state = false;")]),t._v(" "),a("p",[t._v("//玩家与敌人距离")]),t._v(" "),a("p",[t._v("private float _distance;")]),t._v(" "),a("p",[t._v("//角色")]),t._v(" "),a("p",[t._v("public GameObject _role;")]),t._v(" "),a("p",[t._v("//生命值")]),t._v(" "),a("p",[t._v("private int _life = 10;")]),t._v(" "),a("p",[t._v("//敌人被攻击次数")]),t._v(" "),a("p",[t._v("private int _timeAccack = 0;")]),t._v(" "),a("p",[t._v("//敌人状态")]),t._v(" "),a("p",[t._v("public void EnemyState() {")]),t._v(" "),a("p",[t._v("​    if (_distance >= 10f) {")]),t._v(" "),a("p",[t._v("​      if (_life >= 1 && _state == true) {")]),t._v(" "),a("p",[t._v("​        _life -= 1;")]),t._v(" "),a("p",[t._v("​        _timeAccack++;")]),t._v(" "),a("p",[t._v("​      }")]),t._v(" "),a("p",[t._v("​      _state = false;")]),t._v(" "),a("p",[t._v("​    }")]),t._v(" "),a("p",[t._v("​    else if (_distance >= 0 && _state == false) {")]),t._v(" "),a("p",[t._v("​      _state = true;")]),t._v(" "),a("p",[t._v("​    }")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("//敌人与玩家距离")]),t._v(" "),a("p",[t._v("public void Distance() {")]),t._v(" "),a("p",[t._v("​    _distance = Vector3.Distance(transform.position, _role.transform.position);")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("void OnGUI() {")]),t._v(" "),a("p",[t._v("​    GUI.TextArea(new Rect(20, 50, 80, 30), _timeAccack.ToString());")]),t._v(" "),a("p",[t._v("​    GUI.TextArea(new Rect(20, 90, 80, 30), _timeAccack.ToString());")]),t._v(" "),a("p",[t._v("​    GUI.TextArea(new Rect(20, 130, 80, 30), _timeAccack.ToString());")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("p",[t._v("}")]),t._v(" "),a("h2",{attrs:{id:"_61-3d空间有三个cube当做点-有一条鱼的模型-要求在三点之间游动-要求转向平滑一点-控制鱼的运动朝向-用四元数和欧拉角"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_61-3d空间有三个cube当做点-有一条鱼的模型-要求在三点之间游动-要求转向平滑一点-控制鱼的运动朝向-用四元数和欧拉角"}},[t._v("#")]),t._v(" 61. 3D空间有三个cube当做点，有一条鱼的模型，要求在三点之间游动，要求转向平滑一点，控制鱼的运动朝向（用四元数和欧拉角）")]),t._v(" "),a("p",[t._v("使用transform.localRotation = Quaternion.Slerp(Quaternion a,Quaternion b,float c)实现物体平滑转向")])])}),[],!1,null,null,null);_.default=v.exports}}]);