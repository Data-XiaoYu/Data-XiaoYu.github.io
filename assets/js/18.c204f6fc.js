(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{532:function(_,v,a){"use strict";a.r(v);var t=a(5),e=Object(t.a)({},(function(){var _=this,v=_.$createElement,a=_._self._c||v;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h1",{attrs:{id:"八、图形学相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、图形学相关"}},[_._v("#")]),_._v(" 八、图形学相关")]),_._v(" "),a("h2",{attrs:{id:"_1-简述四元数的作用-四元数对欧拉角的优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-简述四元数的作用-四元数对欧拉角的优点"}},[_._v("#")]),_._v(" 1.    简述四元数的作用，四元数对欧拉角的优点？")]),_._v(" "),a("p",[_._v("四元数用于表示旋转")]),_._v(" "),a("p",[_._v("A.四元数一般定义如下：q=w+xi+yj+zk 其中 w,x,y,z 是实数。同时，有: i"),a("em",[_._v("i=-1 j")]),_._v("j=-1 k*k=-1")]),_._v(" "),a("p",[_._v("B.四元数也可以表示为：q=[w,v] 有多种方式可表示旋转，如 axis/angle、欧拉角(Euler angles)、矩阵(matrix)、四元组等。 相对于其它方法，四元组有其本身的优点：")]),_._v(" "),a("p",[_._v("a.四元数不会有欧拉角存在的 gimbal lock 问题[万向节死锁]")]),_._v(" "),a("p",[_._v("b.四元数由 4 个数组成，旋转矩阵需要 9 个数")]),_._v(" "),a("p",[_._v("c.两个四元数之间更容易插值")]),_._v(" "),a("p",[_._v("d.四元数、矩阵在多次运算后会积攒误差，需要分别对其做规范化(normalize)和正交化 (orthogonalize)，对四元数规范化更容易")]),_._v(" "),a("p",[_._v("e.与旋转矩阵类似，两个四元组相乘可表示两次旋转")]),_._v(" "),a("h2",{attrs:{id:"_2-向量的点乘、叉乘以及归一化的意义"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-向量的点乘、叉乘以及归一化的意义"}},[_._v("#")]),_._v(" 2.    向量的点乘、叉乘以及归一化的意义？")]),_._v(" "),a("p",[_._v("1）点乘描述了两个向量的相似程度，结果越大两向量越相似，还可表示投影")]),_._v(" "),a("p",[_._v("2）叉乘得到的向量垂直于原来的两个向量")]),_._v(" "),a("p",[_._v("3）标准化向量：用在只关系方向，不关心大小的时候")]),_._v(" "),a("h2",{attrs:{id:"_3-矩阵相乘的意义及注意点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-矩阵相乘的意义及注意点"}},[_._v("#")]),_._v(" 3.    矩阵相乘的意义及注意点")]),_._v(" "),a("p",[_._v("用于表示线性变换：旋转、缩放、投影、平移、仿射")]),_._v(" "),a("p",[_._v("注意矩阵的蠕变：误差的积累")]),_._v(" "),a("h2",{attrs:{id:"_4-alpha-blend-工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-alpha-blend-工作原理"}},[_._v("#")]),_._v(" 4.    alpha blend 工作原理")]),_._v(" "),a("p",[_._v("实际显示颜色 = 前景颜色"),a("em",[_._v("Alpha/255 + 背景颜色")]),_._v("(255-Alpha)/255")]),_._v(" "),a("h2",{attrs:{id:"_5-写光照计算中的-diffuse-的计算公式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-写光照计算中的-diffuse-的计算公式"}},[_._v("#")]),_._v(" 5.    写光照计算中的 diffuse 的计算公式")]),_._v(" "),a("p",[_._v("实际光照强度 I= 环境光(Iambient) + 漫反射光(Idiffuse) + 镜面高光(Ispecular);")]),_._v(" "),a("p",[_._v("环境光：Iambient= Aintensity* Acolor; (Aintensity 表示环境光强度，Acolor 表示环境光颜色)")]),_._v(" "),a("p",[_._v("漫反射光：Idiffuse = Dintensity"),a("em",[_._v("Dcolor")]),_._v("N.L;(Dintensity 表示漫反射强度，Dcolor 表示漫反射光颜色，N 为该点的法向量，L 为光源向量)")]),_._v(" "),a("p",[_._v("镜面反射光：Ispecular = Sintensity"),a("em",[_._v("Scolor")]),_._v("(R.V)^n;(Sintensity 表示镜面光照强度，Scolor 表示镜面光颜色，R 为光的反射向量，V 为观察者向量，n 称为镜面光指数)")]),_._v(" "),a("h2",{attrs:{id:"_6-两种阴影判断的方法工作原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-两种阴影判断的方法工作原理"}},[_._v("#")]),_._v(" 6.    两种阴影判断的方法工作原理")]),_._v(" "),a("p",[_._v("阴影由两部分组成：本影与半影")]),_._v(" "),a("p",[_._v("本影：景物表面上那些没有被光源直接照射的区域（全黑的轮廓分明的区域）")]),_._v(" "),a("p",[_._v("半影：景物表面上那些被某些特定光源直接照射但并非被所有特定光源直接照射的区域（半明半暗区域）")]),_._v(" "),a("p",[_._v("求阴影区域的方法：做两次消隐过程")]),_._v(" "),a("p",[_._v("一次对每个光源进行消隐，求出对于光源而言不可见的区域 L；")]),_._v(" "),a("p",[_._v("一次对视点的位置进行消隐，求出对于视点而言可见的面 S；")]),_._v(" "),a("p",[_._v("shadow area = L ∩ S")]),_._v(" "),a("p",[_._v("阴影分为两种：自身阴影和投射阴影")]),_._v(" "),a("p",[_._v("自身阴影：因物体自身的遮挡而使光线照射不到它上面的某些可见面")]),_._v(" "),a("p",[_._v("工作原理：利用背面剔除的方法求出，即假设视点在点光源的位置。")]),_._v(" "),a("p",[_._v("投射阴影：因不透明物体遮挡光线使得场景中位于该物体后面的物体或区域受不到光照照射而形成的阴影")]),_._v(" "),a("p",[_._v("工作原理：从光源处向物体的所有可见面投射光线，将这些面投影到场景中得到投影面，再将这些投影面与场景中的其他平面求交得出阴影多边形，保存这些阴影多边形信息，然后再按视点位置对场景进行相应处理得到所要求的视图（利用空间换时间，每次只需依据视点位置进行一次阴影计算即可，省去了一次消隐过程）若是动态光源此方法就无效了。")]),_._v(" "),a("h2",{attrs:{id:"_7-vertex-shader-是什么-怎么计算"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-vertex-shader-是什么-怎么计算"}},[_._v("#")]),_._v(" 7.   Vertex Shader 是什么？怎么计算？")]),_._v(" "),a("p",[_._v("顶点着色器是一段执行在 GPU 上的程序，用来取代 fixed pipeline 中的 transformation和 lighting，Vertex Shader 主要操作顶点。")]),_._v(" "),a("p",[_._v("Vertex Shader 对输入顶点完成了从 local space 到 homogeneous space（齐次空间）的变换过程，homogeneous space 即 projection space 的下一个 space。在这其间共有 worldtransformation, view transformation 和 projection transformation 及 lighting 几个过程。")]),_._v(" "),a("h2",{attrs:{id:"_8-什么是渲染管道"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-什么是渲染管道"}},[_._v("#")]),_._v(" 8.    什么是渲染管道？")]),_._v(" "),a("p",[_._v("是指在显示器上为了显示出图像而经过的一系列必要操作。 渲染管道中的很多步骤，都要将几何物体从一个坐标系中变换到另一个坐标系中去。主要步骤有：")]),_._v(" "),a("p",[_._v("本地坐标->视图坐标->背面裁剪->光照->裁剪->投影->视图变换->光栅化。")]),_._v(" "),a("h2",{attrs:{id:"_9-怎么判断两个平面是否相交-不能用碰撞体-说出计算方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-怎么判断两个平面是否相交-不能用碰撞体-说出计算方法"}},[_._v("#")]),_._v(" 9.    怎么判断两个平面是否相交?不能用碰撞体,说出计算方法")]),_._v(" "),a("p",[_._v("对于两个平面Ax+By+Cz+D=0与ax+by+cz+d=0，只要(A,B,C)与(a,b,c)不成比例，这两个平面就是相交的。")]),_._v(" "),a("h2",{attrs:{id:"_10-法线贴图-、cg-动画"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-法线贴图-、cg-动画"}},[_._v("#")]),_._v(" 10. 法线贴图 、CG 动画")]),_._v(" "),a("p",[_._v("A.法线贴图：是在原物体的凹凸表面的每个点上均作法线，通过 RGB 颜色通道来标记法线的方向， 你可以把它理解成与原凹凸表面平行的另一个不同的表面，但实际上它又只是一个光滑的平面。")]),_._v(" "),a("p",[_._v("B.CG 动画：原为 Computer Graphics 的英文缩写。随着以计算机为主要工具进行视觉设计和生产的一系列相关产业的形成,国际上习惯将利用计算机技术进行视觉设计和生产的领域通称为 CG。它既包括技术也包括艺术，几乎囊括了当今电脑时代中所有的视觉艺术创作活动，如平面印刷品的设计、网页设计、三维动画、影视特效、多媒体技术、以计算机辅助设计为主的建筑设计及工业造型设计等。")]),_._v(" "),a("h2",{attrs:{id:"_11-什么是局部坐标-什么是世界坐标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-什么是局部坐标-什么是世界坐标"}},[_._v("#")]),_._v(" 11. 什么是局部坐标，什么是世界坐标？")]),_._v(" "),a("p",[_._v("世界坐标是不会变的，一直以世界坐标轴的 XYZ 为标准。 局部坐标其实就是自身的坐标，会随着物体的旋转而变化的。")]),_._v(" "),a("h2",{attrs:{id:"_12-请描述-meshrender-中-material-和-shader-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-请描述-meshrender-中-material-和-shader-的区别"}},[_._v("#")]),_._v(" 12. 请描述 MeshRender 中 material 和 shader 的区别？")]),_._v(" "),a("p",[_._v("Shader（着色器）实际上就是一小段程序，它负责将输入的 Mesh（网格）以指定的方式和输入的贴图或者颜色等组合作用，然后输出。绘图单元可以依据这个输出来将图像绘制到屏幕上。输入的贴图或者颜色等，加上对应的 Shader，以及对 Shader 的特定的参数设置，将这些内容（Shader 及输入参数）打包存储在一起，得到的就是一个 Material（材质）Shader 大体上可以分为两类:表面着色器（Surface Shader） 、片段着色器（Fragment Shader）")]),_._v(" "),a("h2",{attrs:{id:"_13-什么是矢量图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-什么是矢量图"}},[_._v("#")]),_._v(" 13. 什么是矢量图")]),_._v(" "),a("p",[_._v("矢量图：计算机中显示的图形一般可以分为两大类——矢量图和位图。矢量图使用直线和曲线来描述图形，这些图形的元素是一些点、线、矩形、多边形、圆和弧线等等，它们都是通过数学公式计算获得的。例如一幅花的矢量图形实际上是由线段形成外框轮廓， 由外框的颜色以及外框所封闭的颜色决定花显示出的颜色。由于矢量图形可通过公式计算获得，所以矢量图形文件体积一般较小。矢量图形最大的优点是无论放大、缩小或旋转等不会失真；最大的缺点是难以表现色彩层次丰富的逼真图像效果。")]),_._v(" "),a("h2",{attrs:{id:"_14-四元组是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-四元组是什么"}},[_._v("#")]),_._v(" 14. 四元组是什么?")]),_._v(" "),a("p",[_._v("所谓四元数，就是把 4 个实数组合起来的东西。4 个元素中，一个是实部，其余 3 个是虚部。")]),_._v(" "),a("h2",{attrs:{id:"_15-你对你的数学知识感觉如何-比如空间向量-图形学"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-你对你的数学知识感觉如何-比如空间向量-图形学"}},[_._v("#")]),_._v(" 15. 你对你的数学知识感觉如何？比如空间向量，图形学")]),_._v(" "),a("p",[_._v("个人感觉还是不错的，空间向量和图形学之前有自学过。只是在实际工作中直接使用的机会比较少，底层的一些操作有些生疏了。")]),_._v(" "),a("h2",{attrs:{id:"_16-会写shader么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-会写shader么"}},[_._v("#")]),_._v(" 16. 会写shader么")]),_._v(" "),a("p",[_._v("了解一些，但是写的不多")]),_._v(" "),a("h2",{attrs:{id:"_17-3d基础相关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-3d基础相关"}},[_._v("#")]),_._v(" 17. 3D基础相关")]),_._v(" "),a("p",[_._v("2 1 0    1 0 1")]),_._v(" "),a("p",[_._v("1 0 1  ×  0 0 0")]),_._v(" "),a("p",[_._v("2 1 1    1 1 1")]),_._v(" "),a("p",[_._v("上述两个矩阵相乘的结果")]),_._v(" "),a("p",[_._v("2  0  2")]),_._v(" "),a("p",[_._v("2  1  2")]),_._v(" "),a("p",[_._v("3  1  3")]),_._v(" "),a("h2",{attrs:{id:"_18-什么是投影矩阵"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-什么是投影矩阵"}},[_._v("#")]),_._v(" 18. 什么是投影矩阵")]),_._v(" "),a("p",[_._v("投影矩阵是一个典型的缩放和透视矩阵。投影变换将视锥变换成一个直平行六面体的形状。因为视锥的近处比远处小，这样就会对靠近摄像机的对象起到放大的作用，也就将透视应用到了场景当中")]),_._v(" "),a("h2",{attrs:{id:"_19-什么是uv"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-什么是uv"}},[_._v("#")]),_._v(" 19. 什么是UV")]),_._v(" "),a("p",[_._v("UV坐标是指所有的图象文件都是二维的一个平面。水平方向是U，垂直方向是V，通过这个平面的，二维的UV坐标系。我们可以定位图象上的任意一个象素。")]),_._v(" "),a("h2",{attrs:{id:"_20-cullback-cullfront-culloff区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-cullback-cullfront-culloff区别"}},[_._v("#")]),_._v(" 20. Cullback，cullfront，culloff区别")]),_._v(" "),a("p",[_._v("剔除背面、剔除前面、不剔除")]),_._v(" "),a("h2",{attrs:{id:"_21-什么是顶点程序和片段程序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-什么是顶点程序和片段程序"}},[_._v("#")]),_._v(" 21. 什么是顶点程序和片段程序")]),_._v(" "),a("p",[_._v("顶点着色器是一组指令代码，这组指令代码在顶点被渲染时执行。")]),_._v(" "),a("p",[_._v("片段着色器也是在 GPU 上运行的小程序。它们负责输出每个呈现的三角形像素的最终像素颜色。基本而言，它的工作原理如下：片段着色器以输入的形式收到顶点着色器通过管道传递的所有这些片段。")]),_._v(" "),a("h2",{attrs:{id:"_22-如何实现以下人物在树丛中部分透明效果"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-如何实现以下人物在树丛中部分透明效果"}},[_._v("#")]),_._v(" 22. 如何实现以下人物在树丛中部分透明效果？")]),_._v(" "),a("p",[_._v('Shader "Custom/PlayerDiffuse" {')]),_._v(" "),a("p",[_._v("Properties {")]),_._v(" "),a("p",[_._v('​    _NotVisibleColor ("NotVisibleColor (RGB) ", Color) = (0.3,0.3,0.3,1)')]),_._v(" "),a("p",[_._v('​    _MainTex ("Base (RGB) ", 2D) = "white"{}')]),_._v(" "),a("p",[_._v("}")]),_._v(" "),a("p",[_._v("SubShader {")]),_._v(" "),a("p",[_._v('​    Tags { "Queue"= "Geometry+500""RenderType"="Opaque"}')]),_._v(" "),a("p",[_._v("​    LOD 200")]),_._v(" "),a("p",[_._v("​    Pass {")]),_._v(" "),a("p",[_._v("​      ZTest Greater")]),_._v(" "),a("p",[_._v("​      Lighting Off")]),_._v(" "),a("p",[_._v("​      ZWrite Off")]),_._v(" "),a("p",[_._v("​      //Color [_NotVisibleColor]")]),_._v(" "),a("p",[_._v("​      Blend SrcAlpha OneMinusSrcAlpha")]),_._v(" "),a("p",[_._v("​      SetTexture [_MainTex] { ConstantColor [_NotVisibleColor] combine constant * texture }")]),_._v(" "),a("p",[_._v("​    }")]),_._v(" "),a("p",[_._v("​    Pass {")]),_._v(" "),a("p",[_._v("​      ZTest LEqual")]),_._v(" "),a("p",[_._v("​      Material {")]),_._v(" "),a("p",[_._v("​        Diffuse (1,1,1,1)")]),_._v(" "),a("p",[_._v("​        Ambient (1,1,1,1)")]),_._v(" "),a("p",[_._v("​      }")]),_._v(" "),a("p",[_._v("​      Lighting Off")]),_._v(" "),a("p",[_._v("​      SetTexture [_MainTex] { combine texture }")]),_._v(" "),a("p",[_._v("​    }")]),_._v(" "),a("p",[_._v("}")]),_._v(" "),a("p",[_._v('FallBack "Diffuse"')]),_._v(" "),a("p",[_._v("}")]),_._v(" "),a("h2",{attrs:{id:"_23-简述lightmap的使用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-简述lightmap的使用"}},[_._v("#")]),_._v(" 23. 简述lightmap的使用")]),_._v(" "),a("p",[_._v("(此为帖子全文,请自己简述)")]),_._v(" "),a("p",[_._v("Unity 完全集成了光照贴图，可以通过编辑器创建完整的光照贴图，你完全不用担心，所有材质会自动获得光照贴图。光照贴图的意思是，所有灯光的特性将被直接映射到Beast lightmapper并烘培到纹理，以此获得更好的性能。UnityPro版扩展了全局光照功能，可以烘焙出真实而漂亮的光照，当然这就不能同时使用实时光照。此外，Unity专业版带给你天光和发光材质，为你增加更有趣的场景照明。")]),_._v(" "),a("p",[_._v("在此页中，你会发现更深入的描述，可以找到在Lightmapping窗口的所有属性。从菜单中Window – Lightmapping打开Lightmapping窗口。")]),_._v(" "),a("p",[_._v("物体")]),_._v(" "),a("p",[_._v("物体的烘培设置：灯光、网格渲染和地形 - 取决于当前的选择。")]),_._v(" "),a("p",[_._v("网格渲染器和地形：")]),_._v(" "),a("p",[_._v("·Static 静态")]),_._v(" "),a("p",[_._v("可渲染网格和地形必须标记为静态才能被烘培。")]),_._v(" "),a("p",[_._v("·Scale In Lightmap 光照图比率")]),_._v(" "),a("p",[_._v("（只作用于可渲染网格）特别大的数值将分配给可渲染网格更大的分辨率。最终分辨率比例（光照图缩放）*（物体世界坐标空间所占面积）*全局分辨率烘培设置）如果设置为0物体将不被烘培。（但是它依旧对其他的物体有影响）")]),_._v(" "),a("p",[_._v("·Lightmap Size 光照图大小")]),_._v(" "),a("p",[_._v("（只作用于地形）光照贴图尺寸是地形实例独有的属性，地形将不和其他物体共用图集。地形光照贴图将存贮在一个单独的文件中。")]),_._v(" "),a("p",[_._v("·Atlas 图集")]),_._v(" "),a("p",[_._v("图集信息-如果Lock Atlas（锁定图集）选项没有开启那么这些参数将自动更新。如果Lock Atlas（锁定图集）选项开启，这些参数将不会自动编辑。但是你可以手动设置他们。")]),_._v(" "),a("p",[_._v("·Lightmap Index 光照图索引")]),_._v(" "),a("p",[_._v("光照贴图序列中的索引。")]),_._v(" "),a("p",[_._v("·Tiling 平铺")]),_._v(" "),a("p",[_._v("（只作用于可渲染网格）物体光照贴图UVs平铺。")]),_._v(" "),a("p",[_._v("·Offset 偏移")]),_._v(" "),a("p",[_._v("（只作用于可渲染网格）物体UVs的偏移。")]),_._v(" "),a("p",[_._v("Lights 灯光：")]),_._v(" "),a("p",[_._v("·Lightmapping 光照贴图")]),_._v(" "),a("p",[_._v("光照图模式：仅实时模式，自动模式和仅烘培 模式。查看下面Dual Lightmaps的描述。")]),_._v(" "),a("p",[_._v("·Color 颜色")]),_._v(" "),a("p",[_._v("灯光颜色。一些属性只作用于实时光照。")]),_._v(" "),a("p",[_._v("·Intensity 光强度")]),_._v(" "),a("p",[_._v("灯光照明强度。一些属性只作用于实时光照。")]),_._v(" "),a("p",[_._v("·Bounce Intensity 反弹强度")]),_._v(" "),a("p",[_._v("特定光源间接光照强度的倍增值。")]),_._v(" "),a("p",[_._v("·Baked Shadows 烘焙阴影")]),_._v(" "),a("p",[_._v("控制当前灯光是否产生阴影。（当选择自动选项时同时影响实施阴影的产生）")]),_._v(" "),a("p",[_._v("·Shadow Radius 阴影半径")]),_._v(" "),a("p",[_._v("（只作用于点光源和聚光灯）增加这个值将得到一个较柔和的阴影。增加这个值的大小影响阴影覆盖面积范围的计算（不会影响到灯光照射范围）。")]),_._v(" "),a("p",[_._v("·Shadow Angle 阴影角度")]),_._v(" "),a("p",[_._v("（只影响平行光）增加这个值将会得到一个比较柔和的阴影-增加灯光阴影覆盖角度范围的计算。（不会影响到灯光照射范围）")]),_._v(" "),a("p",[_._v("·Shadow Samples 阴影采样")]),_._v(" "),a("p",[_._v("如果你将阴影半径或者角度设置为大于0的值，增加阴影采样值能得到一个比较好的结果。高采样值将消除半影中中的噪点。")]),_._v(" "),a("p",[_._v("Bake 烘焙")]),_._v(" "),a("p",[_._v("全局烘焙设置。")]),_._v(" "),a("p",[_._v("·Mode 模式")]),_._v(" "),a("p",[_._v("控制离线烘培和实时光照模式。在Dual Lightmaps 模式下近端和远端光照图都将被烘培；只有延迟光照渲染方式式才能更好的支持双重光照图。Single Lightmaps 模式仅烘培远端光照图。在延迟渲染方式下也可以强制使用单光照图模式。")]),_._v(" "),a("p",[_._v("·Use in forward rendering 使用正向渲染")]),_._v(" "),a("p",[_._v("(Dual lightmaps only) 在正向渲染中启用dual lightmaps。要注意的是这需要你创建自己的shader来达到目的。")]),_._v(" "),a("p",[_._v("·Quality 质量")]),_._v(" "),a("p",[_._v("高质量（比较好的效果）和低质量（计算速度快）的预设值。它们将影响最终聚集光线数量和对比度的数值以及其他有关最终聚集和抗锯齿的设置。")]),_._v(" "),a("p",[_._v("·Bounces 反弹")]),_._v(" "),a("p",[_._v("控制全局光照模拟中光线反弹的次数。如果想得到一个比较柔和的相对真实的光照至少需要将此数值设置为1.如果设置为0那么只会计算直接光照。")]),_._v(" "),a("p",[_._v("·Sky Light Color 天光颜色")]),_._v(" "),a("p",[_._v("天光是模拟从天球向所有方向发射光线照射场景-在烘培室外场景的时候开启天光将得到一个非常好的效果。")]),_._v(" "),a("p",[_._v("·Sky Light Intensity 天光强度")]),_._v(" "),a("p",[_._v("天光的强度 - 0代表禁用天光。")]),_._v(" "),a("p",[_._v("·Bounce Boost 反弹增强")]),_._v(" "),a("p",[_._v("增强间接光， 可用来增加场景中渲染太快没有烘焙出灯光的反弹量。")]),_._v(" "),a("p",[_._v("·Bounce Intensity 反弹强度")]),_._v(" "),a("p",[_._v("间接光照的强度倍增器。")]),_._v(" "),a("p",[_._v("·Final Gather Rays 最终聚集光线")]),_._v(" "),a("p",[_._v("控制从最终聚集点发射的光线数量-较高的数值能得到更好的效果 。")]),_._v(" "),a("p",[_._v("·Contrast Threshold")]),_._v(" "),a("p",[_._v("对比度阈值")]),_._v(" "),a("p",[_._v("颜色对比度根据采样运算规则控制哪些最终聚集点被创建。较高的数值可以使Beast处理物体表面灯光照明时有很大的改善，从而得到一张平滑的光照贴图但是会牺牲一些照明细节。较低的数值需要最终聚集光线数量要高于对比度阈值这样被过滤掉的最终聚集点才能被创建出来。")]),_._v(" "),a("p",[_._v("·Interpolation 插值")]),_._v(" "),a("p",[_._v("控制最终聚集点颜色的插值。设置0为线性插值，设置1为基于梯度的高级插值。多数情况下推荐使用后者。")]),_._v(" "),a("p",[_._v("·Interpolation Points 插值点")]),_._v(" "),a("p",[_._v("设置最终聚集点颜色的插值的参考点。高数值可以获得比较平滑的结果，但是会牺牲一些光照细节。")]),_._v(" "),a("p",[_._v("·Ambient Occlusion")]),_._v(" "),a("p",[_._v("环境光遮挡")]),_._v(" "),a("p",[_._v("烘培光照图时产生一定数量的环境阻光。环境阻光计算物体每一点被一定距离内的其他物体或者一定距离内自身物体的遮挡程度（用来模拟物体表面环境光及阴影覆盖的比例，达到全局光照的效果），所以和所有的灯光设置没有太大关系。")]),_._v(" "),a("p",[_._v("·Max Distance 最大距离")]),_._v(" "),a("p",[_._v("Beyond this distance a ray is considered to be unoccluded. 0 stands for infinitely long rays.")]),_._v(" "),a("p",[_._v("超出这个距离的光线将不被遮挡。0表示无限长的光线。")]),_._v(" "),a("p",[_._v("·Contrast 对比度")]),_._v(" "),a("p",[_._v("控制完全阻光和不阻光之间的过度。")]),_._v(" "),a("p",[_._v("·Lock Atlas 锁定图集")]),_._v(" "),a("p",[_._v("当锁定图集被打开。自动图集功能将不执行，物体光照图索引，平铺和偏移将不能编辑。")]),_._v(" "),a("p",[_._v("·Resolution 分辨率")]),_._v(" "),a("p",[_._v("每世界单位中光照图分辨率的大小。因此当设置分辨率为50的一个10单位乘以10单位的平面将产生一张500*500像素的光照贴图。")]),_._v(" "),a("p",[_._v("Maps 贴图所有光照贴图的可编辑数组。")]),_._v(" "),a("p",[_._v("·Compressed 压缩")]),_._v(" "),a("p",[_._v("控制是否压缩所有当前场景中的光照贴图。")]),_._v(" "),a("p",[_._v("·Array Size 数组大小")]),_._v(" "),a("p",[_._v("光照贴图数组的大小（0～254）。")]),_._v(" "),a("p",[_._v("·Lightmaps Array 光照贴图数组")]),_._v(" "),a("p",[_._v("当前场景被烘培的所有光照图的可编辑序列。没有被指定的通道将被处理为黑色光照图。索引相当于网格渲染和地形中所使用的光照图编号。除非锁定图集被开启否则序列将自动初始化并分配给你烘培的贴图。")]),_._v(" "),a("p",[_._v("Lightmap Display 光照贴图显示")]),_._v(" "),a("p",[_._v("在编辑器中控制光照图如何显示的工具。光照图显示是在场景视口中的一个子窗口。可见只要光照图窗口可见。")]),_._v(" "),a("p",[_._v("·Use Lightmaps 使用光照贴图")]),_._v(" "),a("p",[_._v("是否渲染光照图。")]),_._v(" "),a("p",[_._v("·Shadow Distance 阴影距离")]),_._v(" "),a("p",[_._v("根据过度到只使用远端光照图时哪些设置为自动模式的灯光被关闭的距离。这里的设置覆盖其他面板中相关设置。但是不能覆盖质量设置中的阴影距离设置。")]),_._v(" "),a("p",[_._v("·Show Resolution 显示分辨率")]),_._v(" "),a("p",[_._v("切换在场景中是否显示光照图分辨率。开启这项设置你可以在你的场景中直接预览静态物体光照图的分辨率大小。")]),_._v(" "),a("p",[_._v("Details 细节")]),_._v(" "),a("p",[_._v("Dual Lightmaps 双重光照贴图")]),_._v(" "),a("p",[_._v("双光照贴图是Unity中的光照贴图可以同高光贴图，法线贴图和适当混合的实时阴影一起渲染的工具。同时它也可以让你的光照贴图看起来效果更好，即使设置的光照分辨率较低。")]),_._v(" "),a("p",[_._v("双光照贴图默认情况下只能用于延迟光照渲染路径。但通过编写自定义着色器就可能让双光照贴图用于前向渲染路径中（使用dualforward表面着色指令）。")]),_._v(" "),a("p",[_._v("双光照贴图即意为使用两套光照贴图：")]),_._v(" "),a("p",[_._v("·远 ：包含全部照明")]),_._v(" "),a("p",[_._v("·近 ：包含标记为自动模式的灯光所产生的的间接照明，和标记为仅烘焙模式的灯光，发光材质和天光的所有照明。")]),_._v(" "),a("p",[_._v("设置为仅实时的灯光永远不会被烘培。近端光照图作用于质量设置中的相对摄像机最小阴影距离范围内。")]),_._v(" "),a("p",[_._v("在这个距离范围内，自动模式的灯光将实时渲染高光，凹凸和阴影，（它们的阴影与实时模式的等光的阴影融为一体），间接光则来自近端光照贴图。 若超出阴影距离自动模式灯光就不再进行实时渲染，而全部照明都由光照贴图产生（仅实时模式灯光仍然产生照明，但不产生阴影）。")]),_._v(" "),a("p",[_._v("下面的场景包含一个默认设置为为自动模式的平行光，一些烘培完光照贴图的静态物体（建筑物，障碍物，其他静态物体）和一些动态的移动或可移动物体（持枪的假人，桶）。 该场景在双重光照贴图模式中烘焙和渲染：阴影距离以外的建筑物完全由光照贴图产生照明，而两个假人由实时灯光产生动态光照，但是不投射阴影; 阴影距离范围内的建筑物和地面被即时光照亮并投下实时阴影，但柔和的间接光是来自于近端光照贴图产生。")]),_._v(" "),a("h2",{attrs:{id:"_24-shader的代码实现-大概写一下"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-shader的代码实现-大概写一下"}},[_._v("#")]),_._v(" 24. Shader的代码实现？大概写一下")]),_._v(" "),a("p",[_._v('Shader "Custom/NewSurfaceShader"{')]),_._v(" "),a("p",[_._v("Properties {")]),_._v(" "),a("p",[_._v('​    _Color ("Color", Color) = (1,1,1,1)')]),_._v(" "),a("p",[_._v('​       _MainTex ("Albedo (RGB) ", 2D) = "white" {}')]),_._v(" "),a("p",[_._v('​       _Glossiness ("Smoothness", Range(0,1)) = 0.5')]),_._v(" "),a("p",[_._v('​       _Metallic ("Metallic", Range(0,1)) = 0.0')]),_._v(" "),a("p",[_._v("}")]),_._v(" "),a("p",[_._v("SubShader {")]),_._v(" "),a("p",[_._v('​    Tags { "RenderType"="Opaque" }')]),_._v(" "),a("p",[_._v("​    LOD 200")]),_._v(" "),a("p",[_._v("​    CGPROGRAM")]),_._v(" "),a("p",[_._v("​    // Physically based Standard lighting model, and enable shadows on all light types")]),_._v(" "),a("p",[_._v("​    #pragma surface surf Standard fullforwardshadows")]),_._v(" "),a("p",[_._v("​    // Use shader model 3.0 target, to get nicer looking lighting")]),_._v(" "),a("p",[_._v("​    #pragma target 3.0")]),_._v(" "),a("p",[_._v("​    sampler2D _MainTex;")]),_._v(" "),a("p",[_._v("​    struct Input {")]),_._v(" "),a("p",[_._v("​       float2 uv_MainTex;")]),_._v(" "),a("p",[_._v("​    };")]),_._v(" "),a("p",[_._v("​    half _Glossiness;")]),_._v(" "),a("p",[_._v("​    half _Metallic;")]),_._v(" "),a("p",[_._v("​    fixed4 _Color;")]),_._v(" "),a("p",[_._v("​    void surf (Input IN, inout SurfaceOutputStandard o) {")]),_._v(" "),a("p",[_._v("​       // Albedo comes from a texture tinted by color")]),_._v(" "),a("p",[_._v("​       fixed4 c = tex2D (_MainTex, IN.uv_MainTex) * _Color;")]),_._v(" "),a("p",[_._v("​       o.Albedo = c.rgb;")]),_._v(" "),a("p",[_._v("​       // Metallic and smoothness come from slider variables")]),_._v(" "),a("p",[_._v("​       o.Metallic = _Metallic;")]),_._v(" "),a("p",[_._v("​       o.Smoothness = _Glossiness;")]),_._v(" "),a("p",[_._v("​       o.Alpha = c.a;")]),_._v(" "),a("p",[_._v("​     }")]),_._v(" "),a("p",[_._v("​     ENDCG")]),_._v(" "),a("p",[_._v("}")]),_._v(" "),a("p",[_._v('FallBack "Diffuse"')]),_._v(" "),a("p",[_._v("}")]),_._v(" "),a("h2",{attrs:{id:"_25-游戏中要怎么实现矩阵相乘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-游戏中要怎么实现矩阵相乘"}},[_._v("#")]),_._v(" 25. 游戏中要怎么实现矩阵相乘？")]),_._v(" "),a("p",[_._v("//矩阵相乘")]),_._v(" "),a("p",[_._v("public static float[][] Mul(float[][] a, float[][] b) {")]),_._v(" "),a("p",[_._v("​    //确保矩阵a的列数和b的行数相等")]),_._v(" "),a("p",[_._v("​    if(a[0].length != b.length) {")]),_._v(" "),a("p",[_._v("​      return null;")]),_._v(" "),a("p",[_._v("​    }")]),_._v(" "),a("p",[_._v("​    //用来存放结果的矩阵，axb的结果为a的行数和b的列数")]),_._v(" "),a("p",[_._v("​    float[][] result = new float[a.length][b[0].length];")]),_._v(" "),a("p",[_._v("​    //对a的每行进行遍历")]),_._v(" "),a("p",[_._v("​    for(int i=0; i<a.length; i++) {")]),_._v(" "),a("p",[_._v("​      //对b的每列进行遍历")]),_._v(" "),a("p",[_._v("​      for(int j=0;j<b[0].length; j++) {")]),_._v(" "),a("p",[_._v("​        //c为每一个点的值")]),_._v(" "),a("p",[_._v("​        float c = 0;")]),_._v(" "),a("p",[_._v("​        //第i行j列的值为a的第i行上的n个数和b的第j列上的n个数对应相乘之和，其中n为a的列数，也是b的行数，a的列数和b的行数相等")]),_._v(" "),a("p",[_._v("​        for(int k=0; k<a[0].length; k++) {")]),_._v(" "),a("p",[_._v("​          c += (a[i][k]*b[k][j]);")]),_._v(" "),a("p",[_._v("​        }")]),_._v(" "),a("p",[_._v("​        result[i][j] = c;")]),_._v(" "),a("p",[_._v("​      }")]),_._v(" "),a("p",[_._v("​    }")]),_._v(" "),a("p",[_._v("​    return result;")]),_._v(" "),a("p",[_._v("}")])])}),[],!1,null,null,null);v.default=e.exports}}]);