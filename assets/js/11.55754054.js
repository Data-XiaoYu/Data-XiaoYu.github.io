(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{526:function(_,v,t){"use strict";t.r(v);var a=t(5),r=Object(a.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"一、c-语言"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、c-语言"}},[_._v("#")]),_._v(" 一、C#语言")]),_._v(" "),t("h2",{attrs:{id:"_1-重载和重写的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-重载和重写的区别"}},[_._v("#")]),_._v(" 1.    重载和重写的区别")]),_._v(" "),t("ol",[t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[_._v("所处位置不同 重载在同类中 重写在父子类中\n")])])])]),_._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[_._v("定义方式不同 重载方法名相同 参数列表不同 重写方法名和参数列表都相同\n")])])])]),_._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[_._v("调用方式不同 重载使用相同对象以不同参数调用 重写用不同对象以相同参数调用\n")])])])]),_._v(" "),t("li",[t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[_._v("多态时机不同 重载时编译时多态 重写是运行时多态\n")])])])])]),_._v(" "),t("h2",{attrs:{id:"_2-面向对象的三大特点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-面向对象的三大特点"}},[_._v("#")]),_._v(" 2.    面向对象的三大特点")]),_._v(" "),t("p",[_._v("封装、继承、多态")]),_._v(" "),t("p",[_._v("1.继承： 提高代码重用度，增强软件可维护性的重要手段，符合开闭原则。")]),_._v(" "),t("p",[_._v("2.封装： 封装是将数据和行为相结合，通过行为约束代码修改数据的程度，增强数据的安全性，属性是C#封装实现的最好体现。")]),_._v(" "),t("p",[_._v("3.多态性： 多态性是指同名的方法在不同环境下，自适应的反应出不同得表现，是方法动态展示的重要手段。")]),_._v(" "),t("h2",{attrs:{id:"_3-简述值类型和引用类型有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-简述值类型和引用类型有什么区别"}},[_._v("#")]),_._v(" 3.    简述值类型和引用类型有什么区别")]),_._v(" "),t("p",[_._v("1.值类型存储在内存栈中，引用类型数据存储在内存堆中，而内存单元中存放的")]),_._v(" "),t("p",[_._v("是堆中存放的地址。")]),_._v(" "),t("p",[_._v("2.值类型存取快，引用类型存取慢。")]),_._v(" "),t("p",[_._v("3.值类型表示实际数据，引用类型表示指向存储在内存堆中的数据的指针和引用。")]),_._v(" "),t("p",[_._v("4.栈的内存是自动释放的，堆内存是.NET 中会由 GC 来自动释放。")]),_._v(" "),t("p",[_._v("5.值类型继承自 System.ValueType,引用类型继承自 System.Object。")]),_._v(" "),t("h2",{attrs:{id:"_4-请简述private-public-protected-internal的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-请简述private-public-protected-internal的区别"}},[_._v("#")]),_._v(" 4.    请简述private，public，protected，internal的区别")]),_._v(" "),t("p",[_._v("public：对任何类和成员都公开，无限制访问")]),_._v(" "),t("p",[_._v("private：仅对该类公开")]),_._v(" "),t("p",[_._v("protected：对该类和其派生类公开")]),_._v(" "),t("p",[_._v("internal：只能在包含该类的程序集中访问该类")]),_._v(" "),t("p",[_._v("protected internal：protected + internal")]),_._v(" "),t("h2",{attrs:{id:"_5-c-中所有引用类型的基类是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-c-中所有引用类型的基类是什么"}},[_._v("#")]),_._v(" 5.    C#中所有引用类型的基类是什么")]),_._v(" "),t("p",[_._v("引用类型的基类是 System.Object 值类型的基类是 System.ValueType")]),_._v(" "),t("p",[_._v("同时，值类型也隐式继承自 System.Object")]),_._v(" "),t("h2",{attrs:{id:"_6-请简述-arraylist-和-list-int-的主要区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-请简述-arraylist-和-list-int-的主要区别"}},[_._v("#")]),_._v(" 6.    请简述 ArrayList 和 List < Int>的主要区别")]),_._v(" "),t("p",[_._v("ArrayList 不带泛型 数据类型丢失")]),_._v(" "),t("p",[_._v("List < T > 带泛型 数据类型不丢失")]),_._v(" "),t("h2",{attrs:{id:"_7-请简述-gc-垃圾回收-产生的原因-并描述如何避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-请简述-gc-垃圾回收-产生的原因-并描述如何避免"}},[_._v("#")]),_._v(" 7.    请简述 GC（垃圾回收）产生的原因，并描述如何避免？")]),_._v(" "),t("p",[_._v("GC 为了避免内存溢出而产生的回收机制")]),_._v(" "),t("p",[_._v("避免：1）减少 new 产生对象的次数")]),_._v(" "),t("p",[_._v("2）使用公用的对象（静态成员）")]),_._v(" "),t("p",[_._v("3）将 String 换为 StringBuilder")]),_._v(" "),t("h2",{attrs:{id:"_8-请描述-interface-与抽象类之间的不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_8-请描述-interface-与抽象类之间的不同"}},[_._v("#")]),_._v(" 8.    请描述 Interface 与抽象类之间的不同")]),_._v(" "),t("p",[_._v("1.接口不是类 不能实例化 抽象类可以间接实例化")]),_._v(" "),t("p",[_._v("2.接口是完全抽象 抽象类为部分抽象")]),_._v(" "),t("p",[_._v("3.接口可以多继承 抽象类是单继承")]),_._v(" "),t("h2",{attrs:{id:"_9-下列代码在运行中会产生几个临时对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_9-下列代码在运行中会产生几个临时对象"}},[_._v("#")]),_._v(" 9.    下列代码在运行中会产生几个临时对象？")]),_._v(" "),t("p",[_._v("其实在 C#中第一行是会出错的（Java 中倒是可行）。应该这样初始化：")]),_._v(" "),t("p",[_._v("string b = new string(new char[]{'a','b','c'});")]),_._v(" "),t("p",[_._v("忽略错误的话：")]),_._v(" "),t("p",[_._v('1."abc"')]),_._v(" "),t("p",[_._v("2.a.ToUpper()")]),_._v(" "),t("p",[_._v('3."123"')]),_._v(" "),t("p",[_._v('4.a.ToUpper()+"123"')]),_._v(" "),t("h2",{attrs:{id:"_10-下列代码在运行中会发生什么问题-如何避免"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_10-下列代码在运行中会发生什么问题-如何避免"}},[_._v("#")]),_._v(" 10. 下列代码在运行中会发生什么问题？如何避免？")]),_._v(" "),t("p",[_._v("会产生运行时错误，因为 foreach 是只读的。不能一边遍历一边修改。")]),_._v(" "),t("h2",{attrs:{id:"_11-请简述关键字-sealed-用在类声明和函数声明时的作用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_11-请简述关键字-sealed-用在类声明和函数声明时的作用"}},[_._v("#")]),_._v(" 11. 请简述关键字 Sealed 用在类声明和函数声明时的作用")]),_._v(" "),t("p",[_._v("类声明时可防止其他类继承此类，在方法中声明则可防止派生类重写此方法。")]),_._v(" "),t("h2",{attrs:{id:"_12-反射的实现原理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_12-反射的实现原理"}},[_._v("#")]),_._v(" 12. 反射的实现原理？")]),_._v(" "),t("p",[_._v("可以在加载程序运行时，动态获取和加载程序集，并且可以获取到程序集的信息")]),_._v(" "),t("p",[_._v("反射即在运行期动态获取类、对象、方法、对象数据等的一种重要手段")]),_._v(" "),t("p",[_._v("主要使用的类库：System.Reflection")]),_._v(" "),t("p",[_._v("核心类：")]),_._v(" "),t("p",[_._v("1.Assembly描述了程序集")]),_._v(" "),t("p",[_._v("2.Type描述了类这种类型")]),_._v(" "),t("p",[_._v("3.ConstructorInfo描述了构造函数")]),_._v(" "),t("p",[_._v("4.MethodInfo描述了所有的方法")]),_._v(" "),t("p",[_._v("5.FieldInfo描述了类的字段")]),_._v(" "),t("p",[_._v("6.PropertyInfo描述类的属性")]),_._v(" "),t("p",[_._v("通过以上核心类可在运行时动态获取程序集中的类，并执行类构造产生类对象，动态获取对象的字段或属性值，更可以动态执行类方法和实例方法等。")]),_._v(" "),t("h2",{attrs:{id:"_13-net-与-mono-的关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_13-net-与-mono-的关系"}},[_._v("#")]),_._v(" 13. .Net 与 Mono 的关系？")]),_._v(" "),t("p",[_._v(".Net是一个语言平台，Mono为.Net提供集成开发环境，集成并实现了.NET的编译器、CLR 和基础类库，使得.Net既可以运行在windows也可以运行于 linux，Unix，Mac OS 等。")]),_._v(" "),t("h2",{attrs:{id:"_14-在类的构造函数前加上-static-会报什么错-为什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-在类的构造函数前加上-static-会报什么错-为什么"}},[_._v("#")]),_._v(" 14. 在类的构造函数前加上 static 会报什么错?为什么?")]),_._v(" "),t("p",[_._v("构造函数格式为 public+类名如果加上 static 会报错（静态构造函数不能有访问修饰符）")]),_._v(" "),t("p",[_._v("原因：静态构造函数不允许访问修饰符，也不接受任何参数；无论创建多少类型的对象，静态构造函数只执行一次；运行库创建类实例或者首次访问静态成员之前，运行库调用静态构造函数；静态构造函数执行先于任何实例级别的构造函数；显然也就无法使用 this 和 base 来调用构造函数。")]),_._v(" "),t("h2",{attrs:{id:"_15-c-string-类型比-stringbuilder-类型的优势是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_15-c-string-类型比-stringbuilder-类型的优势是什么"}},[_._v("#")]),_._v(" 15. C# String 类型比 stringBuilder 类型的优势是什么?")]),_._v(" "),t("p",[_._v("如果是处理字符串的话，用 string 中的方法每次都需要创建一个新的字符串对象并且分配新的内存地址，而 stringBuilder 是在原来的内存里对字符串进行修改，所以在字符串处理")]),_._v(" "),t("p",[_._v("方面还是建议用 stringBuilder 这样比较节约内存。但是 string 类的方法和功能仍然还是比 stringBuilder 类要强。")]),_._v(" "),t("p",[_._v("string 类由于具有不可变性（即对一个 string 对象进行任何更改时，其实都是创建另外一个 string 类的对象），所以当需要频繁的对一个 string 类对象进行更改的时候，建议使用StringBuilder 类，StringBuilder 类的原理是首先在内存中开辟一定大小的内存空间，当对此 StringBuilder 类对象进行更改时， 如果内存空间大小不够， 会对此内存空间进行扩充，而不是重新创建一个对象，这样如果对一个字符串对象进行频繁操作的时候，不会造成过多的内存浪费，其实本质上并没有很大区别，都是用来存储和操作字符串的，唯一的区别就在于性能上。")]),_._v(" "),t("p",[_._v("String 主要用于公共 API，通用性好、用途广泛、读取性能高、占用内存小。")]),_._v(" "),t("p",[_._v("StringBuilder 主要用于拼接 String，修改性能好。")]),_._v(" "),t("p",[_._v("不过现在的编译器已经把 String 的 + 操作优化成 StringBuilder 了， 所以一般用String 就可以了")]),_._v(" "),t("p",[_._v("String 是不可变的，所以天然线程同步。")]),_._v(" "),t("p",[_._v("StringBuilder 可变，非线程同步。")]),_._v(" "),t("h2",{attrs:{id:"_16-c-函数-func-string-a-string-b-用-lambda-表达式怎么写"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_16-c-函数-func-string-a-string-b-用-lambda-表达式怎么写"}},[_._v("#")]),_._v(" 16. C# 函数 Func(string a, string b)用 Lambda 表达式怎么写?")]),_._v(" "),t("p",[_._v("(a,b) => {};")]),_._v(" "),t("h2",{attrs:{id:"_17-数列-1-1-2-3-5-8-13-第-n-位数是多少-用-c-递归算法实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_17-数列-1-1-2-3-5-8-13-第-n-位数是多少-用-c-递归算法实现"}},[_._v("#")]),_._v(" 17. 数列 1,1,2,3,5,8,13...第 n 位数是多少?用 C#递归算法实现")]),_._v(" "),t("p",[_._v("public int CountNumber(int num) {")]),_._v(" "),t("p",[_._v("​    if (num == 1 || num == 2) {")]),_._v(" "),t("p",[_._v("​      return 1;")]),_._v(" "),t("p",[_._v("​    } else {")]),_._v(" "),t("p",[_._v("​      return CountNumber(num -1) + CountNumber(num-2);")]),_._v(" "),t("p",[_._v("​    }")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_18-冒泡排序-手写代码"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_18-冒泡排序-手写代码"}},[_._v("#")]),_._v(" 18. 冒泡排序（手写代码）")]),_._v(" "),t("p",[_._v("public static void BubblingSort(int[]array) {")]),_._v(" "),t("p",[_._v("for (int i = 0; i < array.Length; i++){")]),_._v(" "),t("p",[_._v("​     for (int j = array.Length - 1; j > 0; j--){")]),_._v(" "),t("p",[_._v("​       if (array [ j] < array[ i]) {")]),_._v(" "),t("p",[_._v("​         int temp = array[ j];")]),_._v(" "),t("p",[_._v("​         array [ j] = array[ j-1];")]),_._v(" "),t("p",[_._v("​         array[j - 1] = temp;")]),_._v(" "),t("p",[_._v("​       }")]),_._v(" "),t("p",[_._v("​     }")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_19-c-中有哪些常用的容器类-各有什么特点。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_19-c-中有哪些常用的容器类-各有什么特点。"}},[_._v("#")]),_._v(" 19. C#中有哪些常用的容器类，各有什么特点。")]),_._v(" "),t("p",[_._v("List,HashTable,Dictionary,Stack,Queue")]),_._v(" "),t("p",[_._v("List：索引泛型容器 访问速度快 修改速度慢")]),_._v(" "),t("p",[_._v("HashTable/Dictionary：散列表格式 查询效率高 空间占用较大")]),_._v(" "),t("p",[_._v("Stack：后进先出")]),_._v(" "),t("p",[_._v("Queue: 先进先出")]),_._v(" "),t("h2",{attrs:{id:"_20-c-中常规容器和泛型容器有什么区别-哪种效率高"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_20-c-中常规容器和泛型容器有什么区别-哪种效率高"}},[_._v("#")]),_._v(" 20. C#中常规容器和泛型容器有什么区别，哪种效率高？")]),_._v(" "),t("p",[_._v("不带泛型的容器需要装箱和拆箱操作 速度慢 所以泛型容器效率更高 数据类型更安全")]),_._v(" "),t("h2",{attrs:{id:"_21-有哪些常见的数值类"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_21-有哪些常见的数值类"}},[_._v("#")]),_._v(" 21. 有哪些常见的数值类？")]),_._v(" "),t("p",[_._v("简单值类型--包括 整数类型、实数类型、字符类型、布尔类型")]),_._v(" "),t("p",[_._v("复合值类型--包括 结构类型、枚举类型")]),_._v(" "),t("h2",{attrs:{id:"_22-c-中委托和接口有什么区别-各用在什么场合"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_22-c-中委托和接口有什么区别-各用在什么场合"}},[_._v("#")]),_._v(" 22. C#中委托和接口有什么区别？各用在什么场合？")]),_._v(" "),t("p",[_._v("接口（interface）是约束类应该具备的功能集合，约束了类应该具备的功能，使类从千变万化的具体逻辑中解脱出来，便于类的管理和扩展，同时又合理解决了类的单继承问题。")]),_._v(" "),t("p",[_._v("C#中的委托是约束方法集合的一个类，可以便捷的使用委托对这个方法集合进行操作。")]),_._v(" "),t("p",[_._v("在以下情况中使用接口：")]),_._v(" "),t("p",[_._v("1.无法使用继承的场合")]),_._v(" "),t("p",[_._v("2.完全抽象的场合")]),_._v(" "),t("p",[_._v("3.多人协作的场合")]),_._v(" "),t("p",[_._v("以上等等")]),_._v(" "),t("p",[_._v("在以下情况中使用委托：多用于事件处理中")]),_._v(" "),t("h2",{attrs:{id:"_23-c-中unsafe关键字是用来做什么的-什么场合下使用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_23-c-中unsafe关键字是用来做什么的-什么场合下使用"}},[_._v("#")]),_._v(" 23. C#中unsafe关键字是用来做什么的？什么场合下使用？")]),_._v(" "),t("p",[_._v("非托管代码才需要这个关键字 一般用在带指针操作的场合")]),_._v(" "),t("h2",{attrs:{id:"_24-c-中ref和out关键字有什么区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_24-c-中ref和out关键字有什么区别"}},[_._v("#")]),_._v(" 24. C#中ref和out关键字有什么区别？")]),_._v(" "),t("p",[_._v("ref修饰参数，表示进行引用传递，out修饰参数也表示进行引用传递，但传递的引用只为带回返回值 ref又进又出 out不进只出")]),_._v(" "),t("h2",{attrs:{id:"_25-for-foreach-enumerator-movenext的使用-与内存消耗情况"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_25-for-foreach-enumerator-movenext的使用-与内存消耗情况"}},[_._v("#")]),_._v(" 25. For，foreach，Enumerator.MoveNext的使用，与内存消耗情况")]),_._v(" "),t("p",[_._v("for 循环可以通过索引依次进行遍历，foreach和Enumerator.MoveNext通过迭代的方式进行遍历。内存消耗上本质上并没有太大的区别。但是在Unity中的Update中，一般不推荐使用foreach 因为会遗留内存垃圾。")]),_._v(" "),t("h2",{attrs:{id:"_26-函数中多次使用string的-处理-会产生大量内存垃圾-垃圾碎片-有什么好的方法可以解决。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_26-函数中多次使用string的-处理-会产生大量内存垃圾-垃圾碎片-有什么好的方法可以解决。"}},[_._v("#")]),_._v(" 26. 函数中多次使用string的+=处理，会产生大量内存垃圾（垃圾碎片），有什么好的方法可以解决。")]),_._v(" "),t("p",[_._v("通过StringBuilder那进行append，这样可以减少内存垃圾")]),_._v(" "),t("h2",{attrs:{id:"_27-当需要频繁创建使用某个对象时-有什么好的程序设计方案来节省内存"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_27-当需要频繁创建使用某个对象时-有什么好的程序设计方案来节省内存"}},[_._v("#")]),_._v(" 27. 当需要频繁创建使用某个对象时，有什么好的程序设计方案来节省内存？")]),_._v(" "),t("p",[_._v("设计单例模式进行创建对象或者使用对象池")]),_._v(" "),t("h2",{attrs:{id:"_28-jit-和aot区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_28-jit-和aot区别"}},[_._v("#")]),_._v(" 28. JIT 和AOT区别")]),_._v(" "),t("p",[_._v("Just-In-Time - 实时编译")]),_._v(" "),t("p",[_._v("执行慢 安装快 占空间小一点")]),_._v(" "),t("p",[_._v("Ahead-Of-Time - 预先编译")]),_._v(" "),t("p",[_._v("执行快 安装慢 占内存占外存大")]),_._v(" "),t("h2",{attrs:{id:"_29-给定一个存放参数的数组-重新排列数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_29-给定一个存放参数的数组-重新排列数组"}},[_._v("#")]),_._v(" 29. 给定一个存放参数的数组，重新排列数组")]),_._v(" "),t("p",[_._v("void SortArray(Array arr){Array.Sort(arr);}")]),_._v(" "),t("h2",{attrs:{id:"_30-foreach循环迭代时-若把其中的某个元素删除-程序报错-怎么找到那个元素-以及具体怎么处理这种情况-注-try-catch捕捉异常-发送信息不可行"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_30-foreach循环迭代时-若把其中的某个元素删除-程序报错-怎么找到那个元素-以及具体怎么处理这种情况-注-try-catch捕捉异常-发送信息不可行"}},[_._v("#")]),_._v(" 30. Foreach循环迭代时，若把其中的某个元素删除，程序报错，怎么找到那个元素？以及具体怎么处理这种情况？(注：Try.....Catch捕捉异常，发送信息不可行)")]),_._v(" "),t("p",[_._v("foreach 不能进行元素的删除，因为迭代器会锁定迭代的集合，解决方法：记录找到索引或者key值，迭代结束后再进行删除。")]),_._v(" "),t("h2",{attrs:{id:"_31-gameobject-a-new-gameobject-gameobject-b-a-实例化出来了a-将a赋给b-现在将b删除-问a还存在吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_31-gameobject-a-new-gameobject-gameobject-b-a-实例化出来了a-将a赋给b-现在将b删除-问a还存在吗"}},[_._v("#")]),_._v(" 31. GameObject a=new GameObject() GameObject b=a 实例化出来了A，将A赋给B，现在将B删除，问A还存在吗？")]),_._v(" "),t("p",[_._v("存在，b删除只是将它在栈中的内存删除，而A对象本身是在堆中，所以A还存在")]),_._v(" "),t("h2",{attrs:{id:"_32-你拥有a块钱-一瓶水b块钱-每瓶水可以得到一个瓶盖-每c个瓶盖可以换一瓶水请写出函数求解上面题目-上面题目abc为参数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_32-你拥有a块钱-一瓶水b块钱-每瓶水可以得到一个瓶盖-每c个瓶盖可以换一瓶水请写出函数求解上面题目-上面题目abc为参数"}},[_._v("#")]),_._v(" 32. 你拥有A块钱，一瓶水B块钱，每瓶水可以得到一个瓶盖，每C个瓶盖可以换一瓶水请写出函数求解上面题目，上面题目ABC为参数")]),_._v(" "),t("p",[_._v("public static int Buy(int a,int b,int c) {")]),_._v(" "),t("p",[_._v("​      return a/b + ForCap(c,a/b);")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("public static int ForCap(int c,int d) {")]),_._v(" "),t("p",[_._v("​      if (d< c ) {")]),_._v(" "),t("p",[_._v("​          return 0;")]),_._v(" "),t("p",[_._v("​      } else {")]),_._v(" "),t("p",[_._v("​          return d/c + ForCap(c,d/c + d%c);")]),_._v(" "),t("p",[_._v("​      }")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_33-有一排开关-第一个人把所有的开关打开-第二个人按2的倍数的开关-第三个人按3的倍数的开关-以此类推-现在又n个开关-k个人-写函数求最后等两者的开关-输入参数n和k"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_33-有一排开关-第一个人把所有的开关打开-第二个人按2的倍数的开关-第三个人按3的倍数的开关-以此类推-现在又n个开关-k个人-写函数求最后等两者的开关-输入参数n和k"}},[_._v("#")]),_._v(" 33. 有一排开关，第一个人把所有的开关打开，第二个人按2的倍数的开关，第三个人按3的倍数的开关，以此类推，现在又n个开关，k个人，写函数求最后等两者的开关，输入参数n和k")]),_._v(" "),t("p",[_._v("static void Main(string[] args) {")]),_._v(" "),t("p",[_._v("​    int n = int.Parse(Console.ReadLine());")]),_._v(" "),t("p",[_._v("​    int k = int.Parse(Console.ReadLine());")]),_._v(" "),t("p",[_._v("​    Function(100,100);")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("static void Function(int n, int k) {")]),_._v(" "),t("p",[_._v("​    int i, j = 0;")]),_._v(" "),t("p",[_._v("​    bool[] a = new bool[ 1000 ]; //初始false：关灯，true:开灯")]),_._v(" "),t("p",[_._v("​    for (i = 1; i <= k; i++)   //k个人")]),_._v(" "),t("p",[_._v("​      for (j = 1; j <= n; j++) //n个灯")]),_._v(" "),t("p",[_._v("​        if (j % i == 0)")]),_._v(" "),t("p",[_._v("​          a[ j] = !a[ j]; //取反,false变true,原来开变关，关变开")]),_._v(" "),t("p",[_._v("​      for (i = 1; i <= n; i++) //最后输出a[ i]的值就可以了")]),_._v(" "),t("p",[_._v("​        if (a[ i]) //灯亮着")]),_._v(" "),t("p",[_._v("​          Console.WriteLine(i);")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_34-数制转换-将任意整数转换成8进制形式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_34-数制转换-将任意整数转换成8进制形式"}},[_._v("#")]),_._v(" 34. 数制转换，将任意整数转换成8进制形式")]),_._v(" "),t("p",[_._v("static void Main(string[] args) {")]),_._v(" "),t("p",[_._v("int n;")]),_._v(" "),t("p",[_._v("n =int.Parse(Console.ReadLine());")]),_._v(" "),t("p",[_._v('Console.WriteLine("输入的10进制为：{0}",n);')]),_._v(" "),t("p",[_._v('Console.Write("转换为8进制数为: ");')]),_._v(" "),t("p",[_._v("d2o(n);")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("static void d2o(int n) {")]),_._v(" "),t("p",[_._v("if (n > 7) {")]),_._v(" "),t("p",[_._v("​     d2o(n / 8);")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("Console.Write(n%8);")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_35-找出200以内的素数。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_35-找出200以内的素数。"}},[_._v("#")]),_._v(" 35. 找出200以内的素数。")]),_._v(" "),t("p",[_._v("static void Main(string[] args) {")]),_._v(" "),t("p",[_._v("int count = 0;")]),_._v(" "),t("p",[_._v("for (int i = 1; i < 200; i++) { //外层循环：要判断的数")]),_._v(" "),t("p",[_._v("​    for (int j = 2; j <=i; j++){")]),_._v(" "),t("p",[_._v("​      if (i % j == 0&& i!=j) {")]),_._v(" "),t("p",[_._v("​         break;")]),_._v(" "),t("p",[_._v("​       }")]),_._v(" "),t("p",[_._v("​       if (j == i ) { //结束的条件:最后一个数还没有被整除")]),_._v(" "),t("p",[_._v("​         count++;")]),_._v(" "),t("p",[_._v("​         Console.WriteLine(i);")]),_._v(" "),t("p",[_._v("​       }")]),_._v(" "),t("p",[_._v("​    }")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("Console.WriteLine(count);")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_36-打印杨辉三角形"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_36-打印杨辉三角形"}},[_._v("#")]),_._v(" 36. 打印杨辉三角形")]),_._v(" "),t("p",[_._v("public static void YHSJ(){")]),_._v(" "),t("p",[_._v("int  [ ] [ ]a= new int [ 7] [ ] ;")]),_._v(" "),t("p",[_._v("a[ 0] = new int 1];  //a[ 0] 0]=1;")]),_._v(" "),t("p",[_._v("a[ 1] = new int[ 2] ;")]),_._v(" "),t("p",[_._v("for (int i = 0; i < 7; i++) {")]),_._v(" "),t("p",[_._v("​    a[ i] = new int[ i+1] ;")]),_._v(" "),t("p",[_._v("​    a[ i] [ 0] =1;")]),_._v(" "),t("p",[_._v("​    a[ i] [ i]=1;")]),_._v(" "),t("p",[_._v("​    if(i>1) { //求出中间的数据")]),_._v(" "),t("p",[_._v("for(int j=1;j< i; j++){")]),_._v(" "),t("p",[_._v("​        a[ i] [ j]= a[ i-1] [ j-1]+a[ i-1] [ j];")]),_._v(" "),t("p",[_._v("​       }")]),_._v(" "),t("p",[_._v("​    }")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("for (int i=0; i< a.Length; i++) {")]),_._v(" "),t("p",[_._v("​     for (int k = 0; k < a.Length-1-i; k++) {")]),_._v(" "),t("p",[_._v('​       Console.Write("");')]),_._v(" "),t("p",[_._v("​     }")]),_._v(" "),t("p",[_._v("​     for(int j=0;j< a [ i] . Length; j++ ) {")]),_._v(" "),t("p",[_._v('​       Console.Write(a [ i] [ j] + "");')]),_._v(" "),t("p",[_._v("​     }")]),_._v(" "),t("p",[_._v("​     Console.WriteLine();")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_37-中国有句俗话-三天打鱼两天晒网-某人从2000年1月1日起开始-三天打鱼两天晒网-问这个人在今后的某天中-打鱼-还是-晒网"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_37-中国有句俗话-三天打鱼两天晒网-某人从2000年1月1日起开始-三天打鱼两天晒网-问这个人在今后的某天中-打鱼-还是-晒网"}},[_._v("#")]),_._v(" 37. 中国有句俗话“三天打鱼两天晒网”，某人从2000年1月1日起开始“三天打鱼两天晒网”，问这个人在今后的某天中“打鱼”还是”晒网”")]),_._v(" "),t("p",[_._v("public static void Compute(){")]),_._v(" "),t("p",[_._v('Console.WriteLine ((DateTime.Now - DateTime.Parse("2000-01-01")).Days%5<3?"打鱼":"晒网");')]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_38-假设当前市场价一只鸡10元-一只鸭12元5角。请写一个函数showprice-输入参数分别为鸡和鸭的个数-非负整型-功能为显示出总价钱-精确到分。例如调用showprice-5-10-后输出175-00。请注意程序的可读性和易于维护性。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_38-假设当前市场价一只鸡10元-一只鸭12元5角。请写一个函数showprice-输入参数分别为鸡和鸭的个数-非负整型-功能为显示出总价钱-精确到分。例如调用showprice-5-10-后输出175-00。请注意程序的可读性和易于维护性。"}},[_._v("#")]),_._v(" 38. 假设当前市场价一只鸡10元，一只鸭12元5角。请写一个函数ShowPrice，输入参数分别为鸡和鸭的个数（非负整型），功能为显示出总价钱，精确到分。例如调用ShowPrice（5,10）后输出175.00。请注意程序的可读性和易于维护性。")]),_._v(" "),t("p",[_._v("static void ShowPrice(int num_chicken, int num_duck)  {")]),_._v(" "),t("p",[_._v("float totalPrice = 0.00f;")]),_._v(" "),t("p",[_._v("float price_chicken = 10f;")]),_._v(" "),t("p",[_._v("float price_duck = 12.5f;")]),_._v(" "),t("p",[_._v("totalPrice = num_chicken * price_chicken + num_duck * price_duck;")]),_._v(" "),t("p",[_._v('Console.WriteLine("总价钱为：{0:0.00}", totalPrice);')]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("h2",{attrs:{id:"_39-请写一个函数-用于返回n-阶乘-结果末尾连续0的个数-如getzerocount-5-返回1-因为5-120-末尾连续1个0"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_39-请写一个函数-用于返回n-阶乘-结果末尾连续0的个数-如getzerocount-5-返回1-因为5-120-末尾连续1个0"}},[_._v("#")]),_._v(" 39. 请写一个函数，用于返回n!（阶乘）结果末尾连续0的个数，如GetZeroCount（5）返回1,因为5！ = 120，末尾连续1个0")]),_._v(" "),t("p",[_._v("static void Main(string[] args) {")]),_._v(" "),t("p",[_._v("​    int fac = Factorial(5);")]),_._v(" "),t("p",[_._v("​    Console.WriteLine(CountZero(fac));")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("public static int Factorial(int n) {")]),_._v(" "),t("p",[_._v("​    if (n == 1) {")]),_._v(" "),t("p",[_._v("​      return 1;")]),_._v(" "),t("p",[_._v("​    } else {")]),_._v(" "),t("p",[_._v("​      return n * jiecheng(n - 1);")]),_._v(" "),t("p",[_._v("​    }")]),_._v(" "),t("p",[_._v("}")]),_._v(" "),t("p",[_._v("//求连续的0的个数")]),_._v(" "),t("p",[_._v("public static int CountZero(int num) {")]),_._v(" "),t("p",[_._v("​    int result = 0; // 最后的结果")]),_._v(" "),t("p",[_._v("​    String numStr = num.ToString();")]),_._v(" "),t("p",[_._v("​    for (int i = numStr.Length - 1; i >= 0; i--) {")]),_._v(" "),t("p",[_._v("​      if (numStr [ i] == '0') {")]),_._v(" "),t("p",[_._v("​        result ++;")]),_._v(" "),t("p",[_._v("​      } else {")]),_._v(" "),t("p",[_._v("​        break;")]),_._v(" "),t("p",[_._v("​      }")]),_._v(" "),t("p",[_._v("​    }")]),_._v(" "),t("p",[_._v("​    return result;")]),_._v(" "),t("p",[_._v("}")])])}),[],!1,null,null,null);v.default=r.exports}}]);