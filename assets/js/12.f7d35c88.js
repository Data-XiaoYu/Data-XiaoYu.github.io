(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{528:function(a,t,e){"use strict";e.r(t);var _=e(5),r=Object(_.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"二、unity编辑器基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、unity编辑器基础"}},[a._v("#")]),a._v(" 二、Unity编辑器基础")]),a._v(" "),e("h2",{attrs:{id:"_1-请描述游戏动画有几种-以及其原理。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-请描述游戏动画有几种-以及其原理。"}},[a._v("#")]),a._v(" 1.    请描述游戏动画有几种，以及其原理。")]),a._v(" "),e("p",[a._v("主要有关节动画、单一网格模型动画(关键帧动画)、骨骼动画。关节动画把角色分成若干独立部分，一个部分对应一个网格模型，部分的动画连接成一个整体的动画，角色比较灵活 Quake2 中使用了这种动画。单一网络模型动画由一个完整的网格模型构成， 在动画序列的关键帧里记录各个顶点的原位置及其改变量，然后插值运算实现动画效果，角色动画较真实。骨骼动画，广泛应用的动画方式，集成了以上两个方式的优点，骨骼按角色特点组成一定的层次结构，由关节相连，可做相对运动，皮肤作为单一网格蒙在骨骼之外，决定角色的外观。皮肤网格每一个顶点都会受到骨骼的影响，从而实现完美的动画。（骨骼动画是由关节动画发展而来的，如今基本都使用骨骼动画来实现角色动画）")]),a._v(" "),e("h2",{attrs:{id:"_2-物体发生碰撞的必要条件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-物体发生碰撞的必要条件"}},[a._v("#")]),a._v(" 2.    物体发生碰撞的必要条件")]),a._v(" "),e("p",[a._v("物体 A 必须带有（collider+rigidbody）或者 CharacterController，另一个物体也必须至少带有 collider")]),a._v(" "),e("h2",{attrs:{id:"_3-gui与ugui的优点和缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-gui与ugui的优点和缺点"}},[a._v("#")]),a._v(" 3.    GUI与UGUI的优点和缺点")]),a._v(" "),e("p",[a._v("GUI不方便控制，UGUI所见即所得，方便控制。GUI使用在生命周期函数OnGUI中使用，脚本来书写控制。UGUI使用Canvas画布和事件系统。UGUI适应屏幕上比GUI简单。")]),a._v(" "),e("h2",{attrs:{id:"_4-一个场景放置多个carmera并同时处于活动状态-会发生什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-一个场景放置多个carmera并同时处于活动状态-会发生什么"}},[a._v("#")]),a._v(" 4.    一个场景放置多个carmera并同时处于活动状态，会发生什么")]),a._v(" "),e("p",[a._v("实际看到的画面由多个 camera 的画面组成，由 depth、Clear Flag、Culling Mask 都会影响最终合成效果。")]),a._v(" "),e("h2",{attrs:{id:"_5-使用过哪些第三方插件"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-使用过哪些第三方插件"}},[a._v("#")]),a._v(" 5.    使用过哪些第三方插件？")]),a._v(" "),e("p",[a._v("一、界面制作 推荐：NGUI")]),a._v(" "),e("p",[a._v("二、2D 游戏制作 推荐：2D Toolkit //[ˈtu:lkɪt] 工具包，工具箱")]),a._v(" "),e("p",[a._v("三、可视化编程 推荐：PlayMaker")]),a._v(" "),e("p",[a._v("四、插值插件 推荐：iTween,HOTween")]),a._v(" "),e("p",[a._v("五、路径搜寻 推荐：Simple Path")]),a._v(" "),e("p",[a._v("六、美术及动画制作 推荐：RageSpline,Smooth Moves")]),a._v(" "),e("p",[a._v("七、画面增强 推荐：Bitmap2Material,Strumpy Shader Editor")]),a._v(" "),e("p",[a._v("八、摄像机管理 推荐：Security Camera")]),a._v(" "),e("p",[a._v("九、资源包 推荐：Nature Pack")]),a._v(" "),e("p",[a._v("十、造路插件 EasyRoads3D")]),a._v(" "),e("h2",{attrs:{id:"_6-u3d-中用于记录节点空间几何信息的组件名称-及其父类名称"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-u3d-中用于记录节点空间几何信息的组件名称-及其父类名称"}},[a._v("#")]),a._v(" 6.    U3D 中用于记录节点空间几何信息的组件名称，及其父类名称")]),a._v(" "),e("p",[a._v("Transform 父类是 Component")]),a._v(" "),e("h2",{attrs:{id:"_7-为何大家都在移动设备上寻求-u3d-原生-gui-的替代方案"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-为何大家都在移动设备上寻求-u3d-原生-gui-的替代方案"}},[a._v("#")]),a._v(" 7.    为何大家都在移动设备上寻求 U3D 原生 GUI 的替代方案")]),a._v(" "),e("p",[a._v("不美观，OnGUI 很耗费时间，使用不方便 ，DrawCall")]),a._v(" "),e("h2",{attrs:{id:"_8-请简述如何在不同分辨率下保持-ui-的一致性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-请简述如何在不同分辨率下保持-ui-的一致性"}},[a._v("#")]),a._v(" 8.    请简述如何在不同分辨率下保持 UI 的一致性")]),a._v(" "),e("p",[a._v("NGUI 很好的解决了这一点，屏幕分辨率的自适应性，原理就是计算出屏幕的宽高比跟原来的预设的屏幕分辨率求出一个对比值，然后修改摄像机的 size。")]),a._v(" "),e("h2",{attrs:{id:"_9-为什么-dynamic-font-在-unicode-环境下优于-static-font"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-为什么-dynamic-font-在-unicode-环境下优于-static-font"}},[a._v("#")]),a._v(" 9.    为什么 dynamic font 在 unicode 环境下优于 static font")]),a._v(" "),e("p",[a._v("Unicode 是国际组织制定的可以容纳世界上所有文字和符号的字符编码方案。使用动态字体时，Unity 将不会预先生成一个与所有字体的字符纹理。当需要支持亚洲语言或者较大的字体的时候，若使用正常纹理，则字体的纹理将非常大。")]),a._v(" "),e("h2",{attrs:{id:"_10-render-的作用-描述-meshrender-和-skinnedmeshrender-的关系与不同"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-render-的作用-描述-meshrender-和-skinnedmeshrender-的关系与不同"}},[a._v("#")]),a._v(" 10. Render 的作用？描述 MeshRender 和 SkinnedMeshRender 的关系与不同")]),a._v(" "),e("p",[a._v("Mesh 就是指模型的网格（同名组件是用于调整网格属性的），MeshFilter 一般是用于获得模型网格的组件，而 MeshRender 是用于把网格渲染出来的组件")]),a._v(" "),e("h2",{attrs:{id:"_11-简述-skinnedmesh-的实现原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-简述-skinnedmesh-的实现原理"}},[a._v("#")]),a._v(" 11.       简述 SkinnedMesh 的实现原理")]),a._v(" "),e("p",[a._v("Skinned Mesh 中文一般称作骨骼蒙皮动画.这种动画中包含骨骼（ Bone ）和蒙皮 (Skinned Mesh) 两个部分， Bone 的层次结构和关节动画类似， Mesh 则和关节动画不同：关节动画中是使用多个分散的 Mesh, 而 Skinned Mesh 中 Mesh 是一个整体，也就是说只有一个 Mesh, 实际上如果没有骨骼让 Mesh 运动变形， Mesh 就和静态模型一样了。Skinned Mesh 技术的精华在于蒙皮，所谓的皮并不是模型的贴图。而是 Mesh 本身，蒙皮是指将 Mesh 中的顶点附着（绑定）在骨骼之上，而且每个顶点可以被多个骨骼所控制，这样在关节处的顶点由于同时受到父子骨骼的拉扯而改变位置就消除了裂缝。可以理解为具有蒙皮信息的 Mesh 或可当做皮肤用的 Mesh ，这个皮肤就是 Mesh 。而为了有皮肤功能， Mesh 还需要蒙皮信息，即 Skin 数据，没有 Skin 数据就是一个普通的静态 Mesh 了。 Skin 数据决定顶点如何绑定到骨骼上。顶点的 Skin 数据包括顶点受哪些骨骼影响以及这些骨骼影响该顶点时的权重 (weight) ，另外对于每块骨骼还需要骨骼偏移矩阵 (BoneOffsetMatrix) 用来将顶点从 Mesh 空间变换到骨骼空间。")]),a._v(" "),e("h2",{attrs:{id:"_12-prefab-的作用-如何在移动环境的设备下恰当地使用它"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-prefab-的作用-如何在移动环境的设备下恰当地使用它"}},[a._v("#")]),a._v(" 12. Prefab 的作用？如何在移动环境的设备下恰当地使用它？")]),a._v(" "),e("p",[a._v("在游戏运行时实例化，prefab 相当于一个模版，对你已有的素材、脚本、参数做一个默认配置，以便于以后修改，同时 prefab 打包的内容简化了导出的操作，便于团队的交流。")]),a._v(" "),e("h2",{attrs:{id:"_13-如何销毁一个-unityengine-object-及其子类"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-如何销毁一个-unityengine-object-及其子类"}},[a._v("#")]),a._v(" 13. 如何销毁一个 UnityEngine.Object 及其子类")]),a._v(" "),e("p",[a._v("Destory")]),a._v(" "),e("h2",{attrs:{id:"_14-为什么unity3d-中会发生在组件上出现数据丢失的情况"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_14-为什么unity3d-中会发生在组件上出现数据丢失的情况"}},[a._v("#")]),a._v(" 14. 为什么Unity3D 中会发生在组件上出现数据丢失的情况？")]),a._v(" "),e("p",[a._v("组件上绑定的对象被删除了")]),a._v(" "),e("h2",{attrs:{id:"_15-meshcollider-和其他-collider-的一个主要不同点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-meshcollider-和其他-collider-的一个主要不同点"}},[a._v("#")]),a._v(" 15. MeshCollider 和其他 Collider 的一个主要不同点？")]),a._v(" "),e("p",[a._v("Meshcollider 是基于顶点的。建议还是用 boxcollider，boxcollider 本身是基于算法，没有面的概念。")]),a._v(" "),e("h2",{attrs:{id:"_16-当一个细小的高速物体撞向另一个较大的物体时-会出现什么情况-如何避免"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-当一个细小的高速物体撞向另一个较大的物体时-会出现什么情况-如何避免"}},[a._v("#")]),a._v(" 16. 当一个细小的高速物体撞向另一个较大的物体时，会出现什么情况？如何避免？")]),a._v(" "),e("p",[a._v("穿透（碰撞检测失败）(碰撞体变大，FixedUpdate, 代码限制)")]),a._v(" "),e("h2",{attrs:{id:"_17-meshrender-中-material-和-sharedmaterial-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-meshrender-中-material-和-sharedmaterial-的区别"}},[a._v("#")]),a._v(" 17. MeshRender 中 material 和 sharedmaterial 的区别？")]),a._v(" "),e("p",[a._v("修改 sharedMaterial 将改变所有物体使用这个材质的外观，并且也改变储存在工程里的材质设置。")]),a._v(" "),e("p",[a._v("不推荐修改由 sharedMaterial 返回的材质。如果你想修改渲染器的材质，使用 material替代。")]),a._v(" "),e("h2",{attrs:{id:"_18-用-u3d-实现-2d-游戏-有几种方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-用-u3d-实现-2d-游戏-有几种方式"}},[a._v("#")]),a._v(" 18. 用 u3d 实现 2d 游戏，有几种方式？")]),a._v(" "),e("p",[a._v("1.利用引擎自带的 GUI和2D系统")]),a._v(" "),e("p",[a._v("2.把摄像机设为 Orthographic，用面片作为 2d 元素")]),a._v(" "),e("p",[a._v("3.利用第三方插件：NGUI、2dToolkit")]),a._v(" "),e("h2",{attrs:{id:"_19-u3d-中碰撞器和触发器的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-u3d-中碰撞器和触发器的区别"}},[a._v("#")]),a._v(" 19. u3d 中碰撞器和触发器的区别？")]),a._v(" "),e("p",[a._v("collider 碰撞器会有碰撞的效果，IsTrigger = false, 可以调用OnCollisionEnter/Stay/Exit 函数trigger 触发器没有碰撞效果, isTrigger = true,可以调用 OnTriggerEnter/stay/exit 函数")]),a._v(" "),e("h2",{attrs:{id:"_20-charactercontroller-和-rigidbody-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-charactercontroller-和-rigidbody-的区别"}},[a._v("#")]),a._v(" 20. CharacterController 和 Rigidbody 的区别")]),a._v(" "),e("p",[a._v("Rigidbody 具有完全真实物理的特性， 而 CharacterController 可以说是受限的 Rigidbody，具有一定的物理效果但不是完全真实的。")]),a._v(" "),e("h2",{attrs:{id:"_21-什么叫做链条关节"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_21-什么叫做链条关节"}},[a._v("#")]),a._v(" 21. 什么叫做链条关节")]),a._v(" "),e("p",[a._v("Hinge Joint ，他可以模拟两个物体间用一根链条连接在一起的情况，能保持两个物体在一个固定距离内部相互移动而不产生作用力，但是达到固定距离后就会产生拉力。 （简单说就是弹簧）")]),a._v(" "),e("h2",{attrs:{id:"_22-unity3d-提供了几种光源-分别是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-unity3d-提供了几种光源-分别是什么"}},[a._v("#")]),a._v(" 22. unity3d 提供了几种光源，分别是什么")]),a._v(" "),e("p",[a._v("平行光：Directional Light")]),a._v(" "),e("p",[a._v("聚光灯：Spot Light")]),a._v(" "),e("p",[a._v("点光源：Point Light")]),a._v(" "),e("p",[a._v("区域光源：Area Light（只用于烘培）")]),a._v(" "),e("h2",{attrs:{id:"_23-u3d-下如何安全的在不同工程迁移-asset-数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23-u3d-下如何安全的在不同工程迁移-asset-数据"}},[a._v("#")]),a._v(" 23. u3d 下如何安全的在不同工程迁移 asset 数据")]),a._v(" "),e("p",[a._v("方法 1，可以把 assets 目录和 Library 目录一起迁移，")]),a._v(" "),e("p",[a._v("方法 2，导出包")]),a._v(" "),e("p",[a._v("方法 3，用 unity 带的 assets server 功能")]),a._v(" "),e("h2",{attrs:{id:"_24-unity3d-中的碰撞器和触发器的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_24-unity3d-中的碰撞器和触发器的区别"}},[a._v("#")]),a._v(" 24.       Unity3d 中的碰撞器和触发器的区别？")]),a._v(" "),e("p",[a._v("触发器只是碰撞器身上的一个属性，碰撞器是触发器的载体。")]),a._v(" "),e("p",[a._v("碰撞器有碰撞的效果，IsTrigger=false，可以调用OnCollisionEnter/Stay/Exit 函数；")]),a._v(" "),e("p",[a._v("触发器没有碰撞效果，IsTrigger=true，可以调用OnTriggerEnter/Stay/Exit 函数。")]),a._v(" "),e("p",[a._v("a.如果不想让碰撞检测影响物体移动但是又想检测到碰撞这时用到触发器（Trigger）")]),a._v(" "),e("p",[a._v("b.触发器用来检测一个物件是否经过空间中的某个区域")]),a._v(" "),e("h2",{attrs:{id:"_25-动画层-animation-layers-的作用是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_25-动画层-animation-layers-的作用是什么"}},[a._v("#")]),a._v(" 25. 动画层(Animation Layers)的作用是什么？")]),a._v(" "),e("p",[a._v("动画层作为一个具有层级动画编辑概念的工具， 可以用来制作和处理任何类型的动画")]),a._v(" "),e("h2",{attrs:{id:"_26-material-和-physic-material-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26-material-和-physic-material-区别"}},[a._v("#")]),a._v(" 26. Material 和 Physic Material 区别？")]),a._v(" "),e("p",[a._v("PhysicMaterial 物理材质：物理材质描述，如何处理物体碰撞（摩擦，弹性）。Material 材质（材质类）为了获得一个对象使用的材质，可以使用 Renderer.materia 属性")]),a._v(" "),e("h2",{attrs:{id:"_27-什么是导航网格-navmesh"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_27-什么是导航网格-navmesh"}},[a._v("#")]),a._v(" 27. 什么是导航网格（NavMesh）？")]),a._v(" "),e("p",[a._v("一种用于实现自动寻路的网格")]),a._v(" "),e("h2",{attrs:{id:"_28-请简述-ngui-中-panel-和-anchor-的作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_28-请简述-ngui-中-panel-和-anchor-的作用"}},[a._v("#")]),a._v(" 28. 请简述 NGUI 中 Panel 和 Anchor 的作用")]),a._v(" "),e("p",[a._v("Anchor 包含 UIAnchor 脚本。 UIAnchor 的功能是把对象锚定在屏幕的边缘 （左上， 左中，左下，上，中，下，右上，右中，右下），或缩放物体使其匹配屏幕的尺寸")]),a._v(" "),e("p",[a._v("Panel 对象有 UIPanel 脚本，UIPanel 是一个容器，它将包含所有 UI 小部件，并负责将所包含的部件组合优化，以减少绘制命令的调用。")]),a._v(" "),e("h2",{attrs:{id:"_29-unity-摄像机有几种工作方式-分别是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_29-unity-摄像机有几种工作方式-分别是什么"}},[a._v("#")]),a._v(" 29. Unity 摄像机有几种工作方式，分别是什么？")]),a._v(" "),e("p",[a._v("perspective透视摄像机和orthographic正交摄像机")]),a._v(" "),e("h2",{attrs:{id:"_30-layermask-nametolayer-这个方法有什么作用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_30-layermask-nametolayer-这个方法有什么作用"}},[a._v("#")]),a._v(" 30. LayerMask.NameToLayer()这个方法有什么作用？")]),a._v(" "),e("p",[a._v("LayerMask 的使用是按位操作的，LayerMask.NameToLayer(“Players”) 返回该 Layer的编号。")]),a._v(" "),e("h2",{attrs:{id:"_31-ngui与ugui的优点和缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_31-ngui与ugui的优点和缺点"}},[a._v("#")]),a._v(" 31. NGUI与UGUI的优点和缺点")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("NGUI还保留着图集，需要进行图集的维护。而UGUI没有图集的概念，可以充分利用资源，避免重复资源。")])]),a._v(" "),e("li",[e("p",[a._v("UGUI出现了锚点的概念，更方便屏幕自适应。")])]),a._v(" "),e("li",[e("p",[a._v("NGUI支持图文混排，UGUI暂未发现支持此功能。")])]),a._v(" "),e("li",[e("p",[a._v("UGUI没有 UIWrap 来循环 scrollview 内容。")])]),a._v(" "),e("li",[e("p",[a._v("UGUI暂时没有集成Tween组件。")])])]),a._v(" "),e("h2",{attrs:{id:"_32-是否熟悉ugui"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_32-是否熟悉ugui"}},[a._v("#")]),a._v(" 32. 是否熟悉UGUI")]),a._v(" "),e("p",[a._v("熟悉，之前在一些项目用UGUI做过界面，和NGUI很相似。")]),a._v(" "),e("h2",{attrs:{id:"_33-会写插件么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_33-会写插件么"}},[a._v("#")]),a._v(" 33. 会写插件么？")]),a._v(" "),e("p",[a._v("了解过，但在公司这块用的比较少，没怎么写过，不过我能很快学会。")]),a._v(" "),e("h2",{attrs:{id:"_34-ugui和ngui的区别-为什么不使用ngui"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_34-ugui和ngui的区别-为什么不使用ngui"}},[a._v("#")]),a._v(" 34. UGUI和NGUI的区别？为什么不使用NGUI？")]),a._v(" "),e("p",[a._v("1、uGUI的Canvas 有世界坐标和屏幕坐标，NGUI有2D和3D区别。")]),a._v(" "),e("p",[a._v("2、uGUI的Image可以使用material。")]),a._v(" "),e("p",[a._v("3、UGUI通过Mask来裁剪，而NGUI通过Panel的Clip")]),a._v(" "),e("p",[a._v("4、NGUI的渲染前后顺序是通过Widget的Depth，而UGUI渲染顺序根据Hierarchy的顺序，越下面渲染在顶层。")]),a._v(" "),e("ol",[e("li",[e("p",[a._v("、UGUI 不需要绑定Colliders，UI可以自动拦截事件。")])]),a._v(" "),e("li",[e("p",[a._v("、UGUI的Anchor是相对父对象，没有提供高级选项，个人感觉uGUI的Anchor操作起来比NGUI更方便")])])]),a._v(" "),e("p",[a._v("7、UGUI没有Atlas一说，使用Sprite Packer。")]),a._v(" "),e("p",[a._v("8、UGUI的Navgation在Scene中能可视化。")]),a._v(" "),e("p",[a._v("9、UGUI的事件需要实现事件系统的接口，但写起来也算简单。")]),a._v(" "),e("p",[a._v("10、NGUI功能更丰富一些")]),a._v(" "),e("p",[a._v("之所以不用NGUI是因为UGUI是Unity官方推出的，慢慢会成为制作UI的主要工具，配套的插件也越来越多，但是具体使用NGUI还是UGUI还要看公司这边，因为这两个我都用过一段时间。")]),a._v(" "),e("h2",{attrs:{id:"_35-ui用的是ngui还是ugui"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_35-ui用的是ngui还是ugui"}},[a._v("#")]),a._v(" 35. UI用的是NGUI还是UGUI？")]),a._v(" "),e("p",[a._v("两个都用过。之前用的NGUI后来用了UGUI。")]),a._v(" "),e("h2",{attrs:{id:"_36-unity3d中static-batching和dynamic-batching-各有什么用"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_36-unity3d中static-batching和dynamic-batching-各有什么用"}},[a._v("#")]),a._v(" 36. Unity3d中static batching和dynamic batching 各有什么用？")]),a._v(" "),e("p",[a._v("Dynamic Batching不需要任何操作，只要共享材质(即使是不同的Mesh模型也可以)，就会自动被合并。可以自由移动旋转。但有以下使用要求：")]),a._v(" "),e("p",[a._v("(1) 模型文件共计点数不超过900。（重复使用同一个Mesh不计）")]),a._v(" "),e("p",[a._v("(2) 单个物体可以不超过300点，Shader可以有法线UV。 但如果Shader使用了 UV0 UV1两套UV,或者Tangent切线的话，单个物体只能不超过180点")]),a._v(" "),e("p",[a._v("(3)游戏对象使用相同模型和材质时，只有相同缩放(即xyz等比缩放,浮点尾数可以有细微差)的会被合并。如")]),a._v(" "),e("p",[a._v("（1，1，1）与（1，1，1）")]),a._v(" "),e("p",[a._v("（2，2，2）与（2，2，2）")]),a._v(" "),e("p",[a._v("（0.5，0.5，0.5）与 （0.5，0.5，0.5）")]),a._v(" "),e("p",[a._v("（2,2,2）与（2,2，2.0001）")]),a._v(" "),e("p",[a._v("(4)场景烘焙：烘焙后同材质将不会被烘焙。lightmap 有隐藏的材质参数：offset/scale, 所以使用lightmap的物体不会被合并")]),a._v(" "),e("p",[a._v("(5)Shader不能使用多Pass:多Pass的Shader会破坏Dynamic Batching")]),a._v(" "),e("p",[a._v("Static Batching")]),a._v(" "),e("p",[a._v("原理：运行游戏后将一组游戏对象的多个模型会被动态合并为1个。这组游戏对象所有使用同一材质的在一个DrawCall来完成。这些游戏对象运行后无法移动缩放旋转。但是Drawcall一定是最大化合并的，并且不受动态合并的诸多限制（见下文详述）。")]),a._v(" "),e("p",[a._v("注意：即使物体都使用了同样的模型，在batch后每一个物体都会创建一份模型对应的geometry,在新的Combined Mesh里。所以过多的batch会增加内存占用。例如场景里的树群就不适合Static Batch，而适合动态合并。")]),a._v(" "),e("p",[a._v("实现方法:")]),a._v(" "),e("p",[a._v("(1)MeshRenderer勾选Batching Static： 勾了即可")]),a._v(" "),e("p",[a._v("(2)代码中使用UnityEngine.StaticBatchingUtility实现(可以在任何平台调用):")]),a._v(" "),e("p",[a._v("1)将所有要合并的静态物体(不须勾Batching Static)放入统一一个root")]),a._v(" "),e("p",[a._v("2)StaticBatchingUtility.Combine(root); 之后就合并好了！")]),a._v(" "),e("p",[a._v("区别：勾选Batching Static：完全自动合并,在MeshFilter里显示的是 Combined Mesh(root:scene)。合并后不能移动")]),a._v(" "),e("p",[a._v('StaticBatchingUtility：合并到一个游戏对象下。合并后可以移动父节点游戏对象"')]),a._v(" "),e("h2",{attrs:{id:"_37-unity3d中awake和start-谁先执行-update和fixedupdate-有什么区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_37-unity3d中awake和start-谁先执行-update和fixedupdate-有什么区别"}},[a._v("#")]),a._v(" 37. Unity3d中Awake和Start 谁先执行，update和fixedUpdate 有什么区别？")]),a._v(" "),e("p",[a._v("Awake先执行。Update是在每次渲染新的一帧的时候才会调用，FixedUpdate，是在固定的时间间隔执行，不受游戏帧率（fps）的影响 ，FixedUpdate的时间间隔可以在项目设置中更改，Edit->Project Setting->time 找到Fixed timestep。就可以修改了")]),a._v(" "),e("h2",{attrs:{id:"_38-unity引擎中以下对mesh-renderer组件描述正确的是哪一项-c"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_38-unity引擎中以下对mesh-renderer组件描述正确的是哪一项-c"}},[a._v("#")]),a._v(" 38. Unity引擎中以下对Mesh Renderer组件描述正确的是哪一项？ C")]),a._v(" "),e("p",[a._v("A．Mesh Renderer组件决定了场景中游戏对象的位置，旋转和缩放")]),a._v(" "),e("p",[a._v("B．为场景中的某一游戏对象增添物理的特性，需要为该游戏对象添加Mesh Renderer组件")]),a._v(" "),e("p",[a._v("C．Mesh Renderer组件从Mesh Filter组件中获得网格信息，病根据物体的Transform组件所定义的位置进行渲染")]),a._v(" "),e("p",[a._v("D．Mesh Renderer是从网格资源中获取网格信息的组件")]),a._v(" "),e("h2",{attrs:{id:"_39-哪种实时光源是-unity-中没有的-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_39-哪种实时光源是-unity-中没有的-d"}},[a._v("#")]),a._v(" 39. 哪种实时光源是 Unity 中没有的？D")]),a._v(" "),e("p",[a._v("A:点光源")]),a._v(" "),e("p",[a._v("B:方向光")]),a._v(" "),e("p",[a._v("C:聚光灯")]),a._v(" "),e("p",[a._v("D:日光灯")]),a._v(" "),e("h2",{attrs:{id:"_40-如何在-unity-中创建地形系统-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_40-如何在-unity-中创建地形系统-a"}},[a._v("#")]),a._v(" 40. 如何在 Unity 中创建地形系统？A")]),a._v(" "),e("p",[a._v("A：Terrain->Create Terrain")]),a._v(" "),e("p",[a._v("B：Component->Create Terrain")]),a._v(" "),e("p",[a._v("C：Asset->Create Terrain")]),a._v(" "),e("p",[a._v("D：Windows->Create Terrain")]),a._v(" "),e("h2",{attrs:{id:"_41-以下哪种操作步骤可以在场景中添加-wind-zone-b"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_41-以下哪种操作步骤可以在场景中添加-wind-zone-b"}},[a._v("#")]),a._v(" 41. 以下哪种操作步骤可以在场景中添加“Wind Zone”？B")]),a._v(" "),e("p",[a._v("A：Terrain -> Wind Zone")]),a._v(" "),e("p",[a._v("B：GameObject -> Create Other -> Wind Zone")]),a._v(" "),e("p",[a._v("C：Component -> Physics -> Wind Zone")]),a._v(" "),e("p",[a._v("D：Assets -> Create -> Wind Zone")]),a._v(" "),e("h2",{attrs:{id:"_42-在-unity-编辑器中创建一个-directional-light-以下步骤正确的是-b"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_42-在-unity-编辑器中创建一个-directional-light-以下步骤正确的是-b"}},[a._v("#")]),a._v(" 42. 在 Unity 编辑器中创建一个 Directional Light，以下步骤正确的是？ B")]),a._v(" "),e("p",[a._v("A：Edit -> Rendering Setting -> Directional Light")]),a._v(" "),e("p",[a._v("B：GameObject -> Create Other -> Directional Light")]),a._v(" "),e("p",[a._v("C：Component -> Rendering -> Directional Light")]),a._v(" "),e("p",[a._v("D：Assets -> Directional Light")]),a._v(" "),e("h2",{attrs:{id:"_43-下列哪一项不属于-camera-中的-clear-flags-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_43-下列哪一项不属于-camera-中的-clear-flags-d"}},[a._v("#")]),a._v(" 43. 下列哪一项不属于 Camera 中的“Clear Flags”？D")]),a._v(" "),e("p",[a._v("A：Skybox")]),a._v(" "),e("p",[a._v("B：Solid Color")]),a._v(" "),e("p",[a._v("C：Depth Only")]),a._v(" "),e("p",[a._v("D：Background")]),a._v(" "),e("h2",{attrs:{id:"_44-以下哪种脚本语言是-unity-编辑器所不支持的-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_44-以下哪种脚本语言是-unity-编辑器所不支持的-d"}},[a._v("#")]),a._v(" 44. 以下哪种脚本语言是 Unity 编辑器所不支持的？ D")]),a._v(" "),e("p",[a._v("A：JavaScript")]),a._v(" "),e("p",[a._v("B：C#")]),a._v(" "),e("p",[a._v("C：Boo")]),a._v(" "),e("p",[a._v("D：Perl")]),a._v(" "),e("h2",{attrs:{id:"_45-对于-prefab-以下说法错误的是-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_45-对于-prefab-以下说法错误的是-d"}},[a._v("#")]),a._v(" 45. 对于 Prefab，以下说法错误的是？ D")]),a._v(" "),e("p",[a._v("A：Prefab 资源可以在项目中多次重复使用")]),a._v(" "),e("p",[a._v("B：由 Prefab 实例出的 GameObject，其在 Hierarchy 视图中表现为蓝色")]),a._v(" "),e("p",[a._v("C：Prefab 上的组件信息一经改变，其实例出的 GameObject 也会自动改变")]),a._v(" "),e("p",[a._v("D：实例出的 GameObject 上的组件信息一经改变，其对应的 Prefab 也会自动改变")]),a._v(" "),e("h2",{attrs:{id:"_46-下面哪种做法可以打开-unity-的-asset-store-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_46-下面哪种做法可以打开-unity-的-asset-store-a"}},[a._v("#")]),a._v(" 46. 下面哪种做法可以打开 Unity 的 Asset Store？ A")]),a._v(" "),e("p",[a._v("A：Windows -> Asset Store")]),a._v(" "),e("p",[a._v("B：Edit -> Asset Store")]),a._v(" "),e("p",[a._v("C：File -> Asset Store")]),a._v(" "),e("p",[a._v("D：Assets -> Asset Store")]),a._v(" "),e("h2",{attrs:{id:"_47-在哪个面板中可以修改物体的空间属性-如位置、朝向、大小等-b"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_47-在哪个面板中可以修改物体的空间属性-如位置、朝向、大小等-b"}},[a._v("#")]),a._v(" 47. 在哪个面板中可以修改物体的空间属性，如位置、朝向、大小等？B")]),a._v(" "),e("p",[a._v("A：Project")]),a._v(" "),e("p",[a._v("B：Inspector")]),a._v(" "),e("p",[a._v("C：Hierarchy")]),a._v(" "),e("p",[a._v("D：Toolbar")]),a._v(" "),e("h2",{attrs:{id:"_48-如何为一个-asset-资源设定一个-label-从而能够方便准确的搜索到-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_48-如何为一个-asset-资源设定一个-label-从而能够方便准确的搜索到-d"}},[a._v("#")]),a._v(" 48. 如何为一个 Asset 资源设定一个 Label，从而能够方便准确的搜索到? D")]),a._v(" "),e("p",[a._v("A：在 Project 窗口中选中一个 Asset,右键->Create->Label")]),a._v(" "),e("p",[a._v("B：在 Project 窗口中选中一个 Asset,右键->Add Label")]),a._v(" "),e("p",[a._v("C：在 Project 窗口中选中一个 Asset,在 Inspector 窗口中点击添加 Label 的图标")]),a._v(" "),e("p",[a._v("D：在 Project 窗口中选中一个 Asset,在 Inspector 窗口中点击按钮“Add Label”")]),a._v(" "),e("h2",{attrs:{id:"_49-mecanim-系统中-body-mask-的作用是-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_49-mecanim-系统中-body-mask-的作用是-d"}},[a._v("#")]),a._v(" 49. Mecanim 系统中，Body Mask 的作用是？D")]),a._v(" "),e("p",[a._v("A:指定身体的某一部分是否参与骨骼动画")]),a._v(" "),e("p",[a._v("B:指定身体的某一部分是否参与物理模拟")]),a._v(" "),e("p",[a._v("C:指定身体的某一部分是否可以输出骨骼信息")]),a._v(" "),e("p",[a._v("D:指定身体的某一部分是否参与渲染")]),a._v(" "),e("h2",{attrs:{id:"_50-以下哪种操作步骤可以打开-unity-编辑器的-lightmapping-视图-c"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_50-以下哪种操作步骤可以打开-unity-编辑器的-lightmapping-视图-c"}},[a._v("#")]),a._v(" 50. 以下哪种操作步骤可以打开 Unity 编辑器的 Lightmapping 视图？ C")]),a._v(" "),e("p",[a._v("A：File --\x3e Lightmapping")]),a._v(" "),e("p",[a._v("B：Assets --\x3e Lightmapping")]),a._v(" "),e("p",[a._v("C：Windows --\x3e Lightmapping")]),a._v(" "),e("p",[a._v("D：Component --\x3e Lightmapping")]),a._v(" "),e("h2",{attrs:{id:"_51-下列关于光照贴图-说法错误的是-c"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_51-下列关于光照贴图-说法错误的是-c"}},[a._v("#")]),a._v(" 51. 下列关于光照贴图，说法错误的是？ C")]),a._v(" "),e("p",[a._v("A：使用光照贴图比使用实时光源渲染要快")]),a._v(" "),e("p",[a._v("B：可以降低游戏内存消耗")]),a._v(" "),e("p",[a._v("C：可以增加场景真实感")]),a._v(" "),e("p",[a._v("D：多个物体可以使用同一张光照贴图")]),a._v(" "),e("h2",{attrs:{id:"_52-如何为物体添加光照贴图所使用的-uv-b"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_52-如何为物体添加光照贴图所使用的-uv-b"}},[a._v("#")]),a._v(" 52. 如何为物体添加光照贴图所使用的 UV？ B")]),a._v(" "),e("p",[a._v("A：不用添加，任何时候都会自动生成")]),a._v(" "),e("p",[a._v("B：更改物体导入设置，勾选“Generate Lightmap UVs”")]),a._v(" "),e("p",[a._v("C：更改物体导入设置，勾选“Swap UVs”")]),a._v(" "),e("p",[a._v("D：更改物体导入设置，在 UVs 选项中选择“Use Lightmaps”")]),a._v(" "),e("h2",{attrs:{id:"_53-在哪个模块下可以修改-render-path-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_53-在哪个模块下可以修改-render-path-a"}},[a._v("#")]),a._v(" 53. 在哪个模块下可以修改 Render Path？ A")]),a._v(" "),e("p",[a._v("A：Camera")]),a._v(" "),e("p",[a._v("B：Light")]),a._v(" "),e("p",[a._v("C：Render Settings")]),a._v(" "),e("p",[a._v("D：Project Settings->Quality")]),a._v(" "),e("h2",{attrs:{id:"_54-以下哪项技术不是目前-unity-所支持的-occlusion-culling-技术-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_54-以下哪项技术不是目前-unity-所支持的-occlusion-culling-技术-d"}},[a._v("#")]),a._v(" 54. 以下哪项技术不是目前 Unity 所支持的 Occlusion Culling 技术？ D")]),a._v(" "),e("p",[a._v("A：PVS only")]),a._v(" "),e("p",[a._v("B：PVS and dynamic objects")]),a._v(" "),e("p",[a._v("C：Automatic Portal Generation")]),a._v(" "),e("p",[a._v("D：Dynamic Only")]),a._v(" "),e("h2",{attrs:{id:"_55-关于-vector3-的-api-以下说法正确的是-c"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_55-关于-vector3-的-api-以下说法正确的是-c"}},[a._v("#")]),a._v(" 55. 关于 Vector3 的 API，以下说法正确的是？ C")]),a._v(" "),e("p",[a._v("A：Vector3.normalize 可以获取一个三维向量的法线向量；")]),a._v(" "),e("p",[a._v("B：Vector3.magnitude 可以获取一个三维向量的长度；")]),a._v(" "),e("p",[a._v("C：Vector3.forward 与 Vector3（0,0,1）是一样的意思；")]),a._v(" "),e("p",[a._v("D：Vector3.Dot（向量 A，向量 B）是用来计算向量 A 与向量 B 的叉积")]),a._v(" "),e("h2",{attrs:{id:"_56-下列那些选项不是网格层属性的固有选项-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_56-下列那些选项不是网格层属性的固有选项-a"}},[a._v("#")]),a._v(" 56. 下列那些选项不是网格层属性的固有选项? A")]),a._v(" "),e("p",[a._v("A：Default")]),a._v(" "),e("p",[a._v("B：Walkable")]),a._v(" "),e("p",[a._v("C：Not Walkable")]),a._v(" "),e("p",[a._v("D：Jump")]),a._v(" "),e("h2",{attrs:{id:"_57-什么是导航网格-navmesh-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_57-什么是导航网格-navmesh-d"}},[a._v("#")]),a._v(" 57. 什么是导航网格（NavMesh）？ D")]),a._v(" "),e("p",[a._v("A：一种用于描述相机轨迹的网格")]),a._v(" "),e("p",[a._v("B：一种被优化过的物体网格")]),a._v(" "),e("p",[a._v("C：一种用于物理碰撞的网格")]),a._v(" "),e("p",[a._v("D：一种用于实现自动寻路的网格")]),a._v(" "),e("h2",{attrs:{id:"_58-以下哪一个选项不属于unity引擎所支持的视频格式文件-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_58-以下哪一个选项不属于unity引擎所支持的视频格式文件-d"}},[a._v("#")]),a._v(" 58. 以下哪一个选项不属于Unity引擎所支持的视频格式文件 D")]),a._v(" "),e("p",[a._v("A．后缀名为mov的文件")]),a._v(" "),e("p",[a._v("B．后缀名为mpg的文件")]),a._v(" "),e("p",[a._v("C．后缀名为avi的文件")]),a._v(" "),e("p",[a._v("D. 后缀名为swf的文件")]),a._v(" "),e("h2",{attrs:{id:"_59-unity引擎使用的是左手坐标系还是右手坐标系-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_59-unity引擎使用的是左手坐标系还是右手坐标系-a"}},[a._v("#")]),a._v(" 59. Unity引擎使用的是左手坐标系还是右手坐标系？ A")]),a._v(" "),e("p",[a._v("A．左手坐标系")]),a._v(" "),e("p",[a._v("B．右手坐标系")]),a._v(" "),e("p",[a._v("C．可以通过Project Setting 切换左右手坐标系")]),a._v(" "),e("p",[a._v("D．可以通过Reference切换左右手坐标系")]),a._v(" "),e("h2",{attrs:{id:"_60-以下哪组摄像机中normalized-view-port-rect的数值设置可以使得摄像机显示的画面位于1280-720分辨率的屏幕画面的右上角-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_60-以下哪组摄像机中normalized-view-port-rect的数值设置可以使得摄像机显示的画面位于1280-720分辨率的屏幕画面的右上角-d"}},[a._v("#")]),a._v(" 60. 以下哪组摄像机中Normalized View Port Rect的数值设置可以使得摄像机显示的画面位于1280*720分辨率的屏幕画面的右上角 D")]),a._v(" "),e("p",[a._v("A. x = 640, Y = -360 , W = 360,H = 360")]),a._v(" "),e("p",[a._v("B. x =640, Y = -360 , W = 360,H = 360")]),a._v(" "),e("p",[a._v("C. x =0.5, Y = 0 , W = 0.5,H = 0.5")]),a._v(" "),e("p",[a._v("C. x =0.5, Y = 0.5 , W = 0.5,H = 0.5")]),a._v(" "),e("h2",{attrs:{id:"_61-以下哪个组件是任何gameobject必备的组件-b"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_61-以下哪个组件是任何gameobject必备的组件-b"}},[a._v("#")]),a._v(" 61. 以下哪个组件是任何GameObject必备的组件 B")]),a._v(" "),e("p",[a._v("A.Mesh Renderer")]),a._v(" "),e("p",[a._v("B.Trtansform")]),a._v(" "),e("p",[a._v("C.Game Object")]),a._v(" "),e("p",[a._v("D.Main camera")]),a._v(" "),e("h2",{attrs:{id:"_62-在unity编辑器中-停止对game视图进行预览播放的快捷键操作是以下哪一项-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_62-在unity编辑器中-停止对game视图进行预览播放的快捷键操作是以下哪一项-a"}},[a._v("#")]),a._v(" 62. 在Unity编辑器中，停止对Game视图进行预览播放的快捷键操作是以下哪一项 A")]),a._v(" "),e("p",[a._v("A．CTRL/CMD + P")]),a._v(" "),e("p",[a._v("B．CTRL/CMD + Shift +P")]),a._v(" "),e("p",[a._v("C．CTRL/CMD + Alt +P")]),a._v(" "),e("p",[a._v("D．CTRL/CMD + S")]),a._v(" "),e("h2",{attrs:{id:"_63-在unity引擎中-depth属性值最大的摄像机会比depth属性值小的摄像机更晚绘制么-a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_63-在unity引擎中-depth属性值最大的摄像机会比depth属性值小的摄像机更晚绘制么-a"}},[a._v("#")]),a._v(" 63. 在Unity引擎中，Depth属性值最大的摄像机会比Depth属性值小的摄像机更晚绘制么？ A")]),a._v(" "),e("p",[a._v("A．是")]),a._v(" "),e("p",[a._v("B．否")]),a._v(" "),e("h2",{attrs:{id:"_64-下列选项中有关animator的说法错误的是-d"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_64-下列选项中有关animator的说法错误的是-d"}},[a._v("#")]),a._v(" 64. 下列选项中有关Animator的说法错误的是 D")]),a._v(" "),e("p",[a._v("A.Animasstor是Unity引擎内置组件")]),a._v(" "),e("p",[a._v("B.任何一个具有动画状态机功能的GameObject都需要一个Animator组件")]),a._v(" "),e("p",[a._v("C.它主要用于角色行为的设置，包括StateMachines，混合Blend trees以及通过脚本控制的事件")]),a._v(" "),e("p",[a._v("D.Animator同Animation组件的用法是相同的")]),a._v(" "),e("h2",{attrs:{id:"_65-下列哪个视图主要用于显示和编辑所选游戏对象或资源的相关属性-c"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_65-下列哪个视图主要用于显示和编辑所选游戏对象或资源的相关属性-c"}},[a._v("#")]),a._v(" 65. 下列哪个视图主要用于显示和编辑所选游戏对象或资源的相关属性 C")]),a._v(" "),e("p",[a._v("A．Scene")]),a._v(" "),e("p",[a._v("B．Project")]),a._v(" "),e("p",[a._v("C．Inspector")]),a._v(" "),e("p",[a._v("D．Hierarchy")]),a._v(" "),e("h2",{attrs:{id:"_66-简述prefab的使用-editor下动态创建prefab的方式-u3d里动态创建对象-需要使用prefab而创建的时候-monobehaviour-instantiate-gameobject-orignal-需要一个作为原型的对象。三种方式获得prefab对象。"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_66-简述prefab的使用-editor下动态创建prefab的方式-u3d里动态创建对象-需要使用prefab而创建的时候-monobehaviour-instantiate-gameobject-orignal-需要一个作为原型的对象。三种方式获得prefab对象。"}},[a._v("#")]),a._v(' 66. 简述Prefab的使用？Editor下动态创建Prefab的方式   "u3d里动态创建对象，需要使用prefab而创建的时候 MonoBehaviour.Instantiate (GameObject orignal) 需要一个作为原型的对象。三种方式获得prefab对象。')]),a._v(" "),e("p",[a._v("方式一：使用脚本的public字段")]),a._v(" "),e("p",[a._v("直接在Project视图里找到做好的prefab，将其拖拽到指定脚本的指定public GameObject 字段。")]),a._v(" "),e("p",[a._v("方式二：Resource类")]),a._v(" "),e("p",[a._v("1、在Assets目录下的任意位置创建一个名为resources的文件夹，将做好的prefab放到这个文件夹下，path形式如下: Assets....\\resources\\prefabName.prefab")]),a._v(" "),e("p",[a._v("2、在代码里使用Resource.Load 或 LoadAll 函数，获得原型对象。指定prefab时不需要指定扩展名（.prefab），形式如下：GameObject prototype = Resource.Load(“prefabName”) as GameObject; 可以有任意数量的resources文件夹，怀疑是Resource类初始化的时候会搜集所有resources文件夹里的文件名。")]),a._v(" "),e("p",[a._v("方式三：加载到场景")]),a._v(" "),e("p",[a._v("一般我们制作Perfab的时候，都是在Hierarchy视图里创建GameObject，然后再搭建Prefab。事后根据需要删除这个原始的GameObject。因此我们可以保留这个GameObject，然后在场景加载后Find这个对象（代码方式），或者使用脚本public字段（编辑器方式）")]),a._v(" "),e("h2",{attrs:{id:"_67-ngui的自适应性是-如果此时屏幕比例变化-屏幕出现黑边怎么办-注-改变ngui和ugui的fixed-size-with-screen不可行"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_67-ngui的自适应性是-如果此时屏幕比例变化-屏幕出现黑边怎么办-注-改变ngui和ugui的fixed-size-with-screen不可行"}},[a._v("#")]),a._v(" 67. NGUI的自适应性是？如果此时屏幕比例变化，屏幕出现黑边怎么办？（注：改变NGUI和UGUI的Fixed size with Screen不可行）")]),a._v(" "),e("p",[a._v("NGUI根目录的UIRoot组件自带了根据高度自适应分辨率的功能。")]),a._v(" "),e("p",[a._v("Scaling Style属性可选择三种不同的缩放策略。")]),a._v(" "),e("p",[a._v("PixelPerfect 完美像素：直接显示设定好的像素。当屏幕高度低于minimum Height时按比例缩小，当屏幕高度大于maximum Height时按比例扩大。")]),a._v(" "),e("p",[a._v("FixedSize 按比例缩放：在设定好的基础上，直接按比例缩放。")]),a._v(" "),e("p",[a._v("FixedSizeOnMobiles 合体版，android和ios为FixedSize方式，其它按照PixelPerfect方式。")])])}),[],!1,null,null,null);t.default=r.exports}}]);