(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{530:function(v,_,t){"use strict";t.r(_);var e=t(5),p=Object(e.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"七、设计模式相关"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#七、设计模式相关"}},[v._v("#")]),v._v(" 七、设计模式相关")]),v._v(" "),t("h2",{attrs:{id:"_1-用过哪些设计模式-谈谈自己比较熟悉的设计模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-用过哪些设计模式-谈谈自己比较熟悉的设计模式"}},[v._v("#")]),v._v(" 1.    用过哪些设计模式？谈谈自己比较熟悉的设计模式")]),v._v(" "),t("p",[v._v("1、工厂模式2、代理模式3、策略模式4、观察者模式6、单例模式")]),v._v(" "),t("p",[v._v("工厂模式：")]),v._v(" "),t("p",[v._v("简单工厂模式解决的问题是如何去实例化一个合适的对象。")]),v._v(" "),t("p",[v._v("简单工厂模式的核心思想就是：有一个专门的类来负责创建实例的过程。凡是出现了大量的产品需要创建，并且具有共同的接口时，可以通过工厂方法模式进行创建。比如说写技能是一系列类，那么就可以使用工厂模式创建。")]),v._v(" "),t("p",[v._v("代理模式：一个是真正的你要访问的对象(目标类)，一个是代理对象,真正对象与代理对象实现同一个接口,先访问代理类再访问真正要访问的对象。")]),v._v(" "),t("p",[v._v("代理模式就是多一个代理类出来，替原对象进行一些操作，比如我们在租房子的时候回去找中介，为什么呢？因为你对该地区房屋的信息掌握的不够全面，希望找一个更熟悉的人去帮你做，此处的代理就是这个意思。再如我们有的时候打官司，我们需要请律师，因为律师在法律方面有专长，可以替我们进行操作，表达我们的想法。")]),v._v(" "),t("p",[v._v("代理模式的应用场景：")]),v._v(" "),t("p",[v._v("如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：")]),v._v(" "),t("p",[v._v("1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。")]),v._v(" "),t("p",[v._v("2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。")]),v._v(" "),t("p",[v._v("使用代理模式，可以将功能划分的更加清晰，有助于后期维护！")]),v._v(" "),t("p",[v._v("策略模式:定义一系列算法，并将每个算法封装起来，使他们可以相互替换，且算法的变化不会影响到使用算法的客户。策略模式的决定权在用户，系统本身提供不同算法的实现，新增或者删除算法，对各种算法做封装。因此，策略模式多用在算法决策系统中，外部用户只需要决定用哪个算法即可。")]),v._v(" "),t("p",[v._v("观察者模式很好理解，类似于邮件订阅和RSS订阅，当我们浏览一些博客或wiki时，经常会看到RSS图标，就这的意思是，当你订阅了该文章，如果后续有更新，会及时通知你。其实，简单来讲就一句话：当一个对象变化时，其它依赖该对象的对象都会收到通知，并且随着变化！对象之间是一种一对多的关系。")]),v._v(" "),t("p",[v._v("单例对象（Singleton）是一种常用的设计模式。在C#应用中，单例对象能保证在一个CLR中，该对象只有一个实例存在。这样的模式有几个好处：")]),v._v(" "),t("p",[v._v("1、某些类创建比较频繁，对于一些大型的对象，这是一笔很大的系统开销。")]),v._v(" "),t("p",[v._v("2、省去了new操作符，降低了系统内存的使用频率，减轻GC压力。")]),v._v(" "),t("p",[v._v("3、有些类如交易所的核心交易引擎，控制着交易流程，如果该类可以创建多个的话，系统完全乱了。（比如一个军队出现了多个司令员同时指挥，肯定会乱成一团），所以只有使用单例模式，才能保证核心交易服务器独立控制整个流程。")]),v._v(" "),t("h2",{attrs:{id:"_2-请说出-4-种面向对象的设计原则-并分别简述它们的含义。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-请说出-4-种面向对象的设计原则-并分别简述它们的含义。"}},[v._v("#")]),v._v(" 2.    请说出 4 种面向对象的设计原则，并分别简述它们的含义。")]),v._v(" "),t("p",[v._v("1）  单一职责原则 （The Single Responsiblity Principle，简称")]),v._v(" "),t("p",[v._v("SRP）：一个类，最好只做一件事，只有一个引起它的变化.")]),v._v(" "),t("p",[v._v("2）  开放－封闭原则 （The Open－Close Principle，简称")]),v._v(" "),t("p",[v._v("OCP）：对于扩展是开放的，对于更改是封闭的")]),v._v(" "),t("p",[v._v("3）  Liskov 替换原则（The Liskov Substitution Principle,简称")]),v._v(" "),t("p",[v._v("LSP）：子类必须能够替换其基类")]),v._v(" "),t("p",[v._v("4）  依赖倒置原则 （The Dependency Inversion Pricinple， 简称")]),v._v(" "),t("p",[v._v("DIP）：依赖于抽象")]),v._v(" "),t("p",[v._v("5）  接口隔离原则 （The Interface Segregation Principle，简称")]),v._v(" "),t("p",[v._v("ISP）：使用多个小的专门的接口，而不要使用一个大的总接口。")]),v._v(" "),t("h2",{attrs:{id:"_3-设计一个状态机类型-状态值为int类型-要求"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-设计一个状态机类型-状态值为int类型-要求"}},[v._v("#")]),v._v(" 3.    设计一个状态机类型，状态值为int类型，要求：")]),v._v(" "),t("p",[v._v("拥有接口，获取当前状态，切换状态")]),v._v(" "),t("p",[v._v("外部可以监听状态切换事件，参数为切换前状态和切换后状态（使用delete和event）//定义一个状态")]),v._v(" "),t("p",[v._v("public abstract class IAction{")]),v._v(" "),t("p",[v._v("public int StateName;")]),v._v(" "),t("p",[v._v("public IAction(int stateName) {")]),v._v(" "),t("p",[v._v("​    this.StateName = stateName;")]),v._v(" "),t("p",[v._v("}")]),v._v(" "),t("p",[v._v("public int GetState(){")]),v._v(" "),t("p",[v._v("​    return StateName;")]),v._v(" "),t("p",[v._v("}")]),v._v(" "),t("p",[v._v("public abstract bool CanGetIn();")]),v._v(" "),t("p",[v._v("public abstract void GetIn();")]),v._v(" "),t("p",[v._v("public abstract void GetOut();")]),v._v(" "),t("p",[v._v("public abstract void Update(float dt);")]),v._v(" "),t("p",[v._v("}")]),v._v(" "),t("p",[v._v("//定义一个状态切换事件")]),v._v(" "),t("p",[v._v("public abstract class IEvent {")]),v._v(" "),t("p",[v._v("public int code;")]),v._v(" "),t("p",[v._v("public IEvent(int code) {")]),v._v(" "),t("p",[v._v("​    this.code = code;")]),v._v(" "),t("p",[v._v("}")]),v._v(" "),t("p",[v._v("public int GetCode(){")]),v._v(" "),t("p",[v._v("​    return code;")]),v._v(" "),t("p",[v._v("}")]),v._v(" "),t("p",[v._v("//当前状态事件检测")]),v._v(" "),t("p",[v._v("public abstract bool Check();")]),v._v(" "),t("p",[v._v("}")]),v._v(" "),t("p",[v._v("public class AvatarStateMachine{")]),v._v(" "),t("p",[v._v("​       //初始化状态机")]),v._v(" "),t("p",[v._v("​       public void InitStateMachine(){}")]),v._v(" "),t("p",[v._v("​       //注册一个状态")]),v._v(" "),t("p",[v._v("​       public void AddAction(int action) {}")]),v._v(" "),t("p",[v._v("​       //注册一个状态切换事件")]),v._v(" "),t("p",[v._v("​       public void AddEventTransition(int fromAction, int toAction, IEvent byEvent) {}")]),v._v(" "),t("p",[v._v("​       //更新当前状态，检测能否进入下一个状态")]),v._v(" "),t("p",[v._v("​       public void UpdateStateMachine(){}")]),v._v(" "),t("p",[v._v("​       //强行切换状态")]),v._v(" "),t("p",[v._v("​       public void SwitchTo(int toState) {}")]),v._v(" "),t("p",[v._v("}")]),v._v(" "),t("h2",{attrs:{id:"_4-如何处理unity中界面资源-界面逻辑以及功能模块三者之间耦合关系"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-如何处理unity中界面资源-界面逻辑以及功能模块三者之间耦合关系"}},[v._v("#")]),v._v(" 4.    如何处理unity中界面资源，界面逻辑以及功能模块三者之间耦合关系")]),v._v(" "),t("p",[v._v("这就是在Unity使用MVC时通常将功能模块尽量脱离脱离MonoBehavior，同一个模块内M只用来操作数据并发送更新消息，V只用来接受消息并控制界面显示跳转，使用C来处理界面与数据的频繁操作。")]),v._v(" "),t("h2",{attrs:{id:"_5-观察者模式的深入理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-观察者模式的深入理解"}},[v._v("#")]),v._v(" 5.    观察者模式的深入理解？")]),v._v(" "),t("p",[v._v("观察者模式：一对多的关系，当被观察这发生改变时会通知所有观察者。让双方都依赖于抽象，使得各自变化不会影响另一方。")]),v._v(" "),t("h2",{attrs:{id:"_6-mvc模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-mvc模式"}},[v._v("#")]),v._v(" 6.    MVC模式")]),v._v(" "),t("p",[v._v("用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。")])])}),[],!1,null,null,null);_.default=p.exports}}]);